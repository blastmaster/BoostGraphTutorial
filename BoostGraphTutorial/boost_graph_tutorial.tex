%% LyX 2.0.8.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\usepackage{listings}
\usepackage{array}
\usepackage{verbatim}
\usepackage{float}
\usepackage{rotfloat}
\usepackage{ifsym}
\usepackage{url}
\usepackage{makeidx}
\makeindex
\usepackage{graphicx}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Special footnote code from the package 'stblftnt.sty'
%% Author: Robin Fairbairns -- Last revised Dec 13 1996
\let\SF@@footnote\footnote
\def\footnote{\ifx\protect\@typeset@protect
    \expandafter\SF@@footnote
  \else
    \expandafter\SF@gobble@opt
  \fi
}
\expandafter\def\csname SF@gobble@opt \endcsname{\@ifnextchar[%]
  \SF@gobble@twobracket
  \@gobble
}
\edef\SF@gobble@opt{\noexpand\protect
  \expandafter\noexpand\csname SF@gobble@opt \endcsname}
\def\SF@gobble@twobracket[#1]#2{}
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}
\floatstyle{ruled}
\newfloat{algorithm}{tbp}{loa}
\providecommand{\algorithmname}{Algorithm}
\floatname{algorithm}{\protect\algorithmname}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{tikz}
\usepackage{tkz-graph}
\usepackage{pgf}
\usetikzlibrary{arrows,automata}

\makeatother

\usepackage{babel}
\begin{document}

\title{A well-connected C++11 Boost.Graph tutorial}


\author{Richèl Bilderbeek}

\maketitle
\begin{center}
\includegraphics[width=0.5\textwidth]{title_graph}
\par\end{center}

\tableofcontents{}


\section{Introduction}

This is 'A well-connected C++11 Boost.Graph tutorial', version 1.9.


\subsection{Why this tutorial}

I needed this tutorial already in 2006, when I started experimenting
with Boost.Graph. More specifically, I needed a tutorial that:
\begin{itemize}
\item Orders concepts chronologically
\item Increases complexity gradually
\item Shows complete pieces of code
\end{itemize}
What I had were the book \cite{siek2001boost} and the Boost.Graph
website, both did not satisfy these requirements. 

This tutorial is intended to take the reader to the level of understanding
the book \cite{siek2001boost} and the Boost.Graph website require.
It is about basic graph manipulation, not the more advanced graph
algorithms. An analogy with std::vector: it teaches the std::vector
member functions, but not the algorithms that work on.


\subsection{Code snippets}

For every concept, I will show
\begin{itemize}
\item the 'do' function\index{'do' function}: a function that achieves
a goal, for example 'create\_empty\_undirected\_graph'
\item the 'demo' function\index{'demo' function}: a function that demonstrates
how to call the first, for example 'create\_empty\_undirected\_graph\_demo'
\end{itemize}
I enjoy to show concepts by putting those in (long-named) functions.
These functions sometimes border the trivial, by, for example, only
calling a single Boost.Graph function. On the other hand, these functions
have more English-sounding names, resulting in demonstration code
that is readable. Additionally, they explicitly mention their return
type (in a simpler way), which may be considered informative.

All coding snippets are taken from compiled C++11 code. I chose to
use C++11 because (1) C++14 was not installable on all my computers
(2) the step to C++14 is small. All code is tested to compile cleanly
under GCC at the highest warning level. The code, as well as this
tutorial, can be downloaded from the GitHub at \url{www.github.com/richelbilderbeek/BoostGraphTutorial}.


\subsection{Coding style}

I use the coding style from the Core C++ Guidelines. At the time of
this writing, the Core C++ Guidelines were still in early development,
so I can only hope the conventions I then chose to follow are still
Good Ideas.

It is important to add comments to code. In this tutorial, however,
I have chosen not to put comments in code, as I already describe the
function in the tutorial its text. This way, it prevents me from saying
the same things twice.

It is good to write generic code. In this tutorial, however, I have
chosen my functions to have no templated arguments for conciseness
and readability. For example, a vertex name is std::string, the type
for if a vertex is selected is a boolean, and the custom vertex type
is of type 'my\_custom\_vertex'. I think these choises are reasonable
and that the resulting increase in readability is worth it.

Due to my long function names and the limitation of \ensuremath{\approx}50
characters per line, sometimes the code does get to look a bit awkward.
I am sorry for this.

I prefer to use the keyword auto over doubling the lines of code for
using statements. Because the 'do' functions return an explicit data
type, these can be used for reference (until 'decltype(auto)'\index{decltype(auto)}
gets into fashion as a return type). If you really want to know a
type, you can use the 'get\_type\_name' function (chapter \ref{sub:get_type_name}). 

On the other hand, I am explicit in the namespaces of functions and
classes I use, so to distinguish between types like 'std::array' and
'boost::array'. Some functions (for example, 'get'\index{get}) reside
in the namespace of the graph to work on. In this tutorial, this is
in the global namespace. Thus, I will write 'get', instead of 'boost::get'\index{boost::get does not exist},
as the latter does not compile.

I try to use STL algorithms wherever I can. Also you should prefer
algorithm calls over hand-written for-loops (\cite{stroustrup1997}
chapter 18.12.1, \cite{meyers2005effective} item 43). Sometimes using
these algorithms becomes a burden on the lines of code. This is because
in C++11, a lambda function argument (use by the algorithm) must have
its data type specified. It may take multiple lines of 'using' statements
being able to do so. In C++14 one can use 'auto' there as well. So,
only if it shortens the number of lines significantly, I use raw for-loops,
even though you shouldn't.


\subsection{Tutorial style}

In the index, I did first put all my long-named functions there literally,
but this resulted in a very sloppy layout. Instead, the function 'do\_something'
can be found as 'Do something' in the index. On the other hand, STL
and Boost functions like 'std::do\_something' and 'boost::do\_something'
can be found as such in the index.


\subsection{License}

This tutorial is licensed under Creative Commons license 4.0. All
C++ code is licensed under GPL 3.0.

\begin{figure}[H]
\includegraphics{CC-BY-SA_icon}

\caption{Creative Commons license 4.0}
\end{figure}



\subsection{Feedback}

This tutorial is not intended to be perfect yet. For that, I need
help and feedback from the community. All referenced feedback is welcome,
as well as any constructive feedback. 

I have tried hard to strictly follow the style as described above.
If you find I deviated from these decisions somewhere, I would be
grateful if you'd let know. Next to this, there are some sections
that need to be coded or have its code improved. 


\subsection{Acknowledgements}

These are users that improved this tutorial and/or the code behind
this tutorial, in chronological order:
\begin{itemize}
\item m-dudley, \url{http://stackoverflow.com/users/111327/m-dudley} 
\item E. Kawashima
\item mat69, \url{https://www.reddit.com/user/mat69}
\item danielhj, \url{https://www.reddit.com/user/danieljh}
\item sehe, \url{http://stackoverflow.com/users/85371/sehe}
\item cv\_and\_me, \url{http://stackoverflow.com/users/2417774/cv-and-he}
\end{itemize}

\subsection{Outline}

The chapters of this tutorial are also like a well-connected graph
(as shown in figure \ref{fig:The-relations-between-chapters}). To
allow for quicker learners to skim chapters, or for beginners looking
to find the patterns, some chapters are repetitions of each other
(for example, getting an edge its name is very similar to getting
a vertex its name)%
\footnote{There was even copy-pasting involved!%
}. This tutorial is not about being short, but being complete, at the
risk of being called bloated.

The distinction between the chapter is in the type of edges and vertices.
They can have:
\begin{itemize}
\item no properties: see chapter \ref{sec:Building-graphs-without-properties}
\item have a name: see chapter \ref{sec:Building-graphs-with-named-vertices}
\item have a bundled property: see chapter \ref{sec:Building-graphs-with-bundled-vertices}
\item have a custom property: see chapter \ref{sec:Building-graphs-with-custom-properties}
\end{itemize}
The differences between graphs with bundled and custom prorties are
shown in table \ref{tab:Difference-between-bundled-and-custom-properties}:

\begin{table}[H]
\begin{tabular}{|c|c|>{\centering}p{0.33\textwidth}|}
\hline 
 & Bundled & Custom\tabularnewline
\hline 
\hline 
Meaning & Edges/vertices are of your type & Edges/vertices have an additional custom property\tabularnewline
\hline 
Interface & Directly & Via property map\tabularnewline
\hline 
Class members & Must be public & Can be private\tabularnewline
\hline 
File I/O mechanism & Via public class members & Via stream operators\tabularnewline
\hline 
File I/O constraints & Restricted to Graphviz attributes & Need encoding and decoding\tabularnewline
\hline 
\end{tabular}

\caption{Difference between bundled and custom properties\label{tab:Difference-between-bundled-and-custom-properties}}


\end{table}


Pivotal chapters are chapters like 'Finding the first vertex with
...', as this opens up the door to finding a vertex and manipulating
it.

\begin{sidewaysfigure}
\includegraphics[width=1\textwidth]{create_tutorial_chapters_graph}

\caption{The relations between chapters\label{fig:The-relations-between-chapters}}
\end{sidewaysfigure}


All chapters have a rather similar structure in themselves, as depicted
in figure \ref{fig:The-relations-between-subchapters}. 

\begin{sidewaysfigure}
\includegraphics[width=1\textwidth]{create_tutorial_subchapters_graph}

\caption{The relations between sub-chapters\label{fig:The-relations-between-subchapters}}
\end{sidewaysfigure}


There are also some bonus chapters, that I have labeled with a \textifsymbol[ifgeo]{100}.
These chapters are added I needed these functions myself and adding
them would not hurt. Just feel free to skip them, as there will be
less theory explained.


\section{Building graphs without properties\label{sec:Building-graphs-without-properties}}

Boost.Graph is about creating graphs. In this chapter we create the
simplest of graphs, in which edges and nodes have no properties (e.g.
having a name). 

Still, there are two types of graphs that can be constructed: undirected
and directed graphs. The difference between directed and undirected
graphs is in the edges: in an undirected graph\index{undirected graph},
an edge connects two vertices without any directionality, as displayed
in figure \ref{fig:undirected_graph_example}. In a directed graph\index{directed graph},
an edge goes from a certain vertex, its source, to another (which
may actually be the same), its target. A directed graph is shown in
figure \ref{fig:directed_graph_example}.

\begin{figure}[H]
\tikz 
\draw[thick] 
  (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 
    -- (5,2) node[draw=black,fill=white,shape=circle,text=white] {} 
    -- (10,1) node[draw=black,fill=white,shape=circle,text=white] {} 
;

\caption{Example of an undirected graph\label{fig:undirected_graph_example}}
\end{figure}


\begin{figure}[H]
\begin{tikzpicture}   
\tikzset{ 
  VertexStyle/.append style = {draw=black,fill=white,shape=circle,text=white},
  EdgeStyle/.append style = {->, bend left} }
\SetGraphUnit{5}
\Vertex{A}   
\EA(A){B}   
\EA(B){C}   
\Edge[](A)(B)   
\Edge[](B)(A)   
\Loop[dist = 4cm, dir = NO](A.west)
\tikzset{EdgeStyle/.append style = {bend left = 0}}
\Edge[](C)(B)   
\end{tikzpicture}

\caption{Example of a directed graph\label{fig:directed_graph_example}}
\end{figure}


In this chapter, we will build two directed and two undirected graphs:
\begin{itemize}
\item An empty (directed) graph, which is the default type: see chapter
\ref{sub:create_empty_directed_graph}
\item An empty (undirected) graph: see chapter \ref{sub:create_empty_undirected_graph}
\item A two-state Markov chain, a directed graph with two vertices and four
edges, chapter \ref{sub:create_markov_chain_graph}
\item $K_{2}$, an undirected graph with two vertices and one edge, chapter
\ref{sub:create_k2_graph}
\end{itemize}
Creating an empty graph may sound trivial, it is not, thanks to the
versatility of the Boost.Graph library.

In the process of creating graphs, some basic (sometimes bordering
trivial) functions are encountered:
\begin{itemize}
\item Counting the number of vertices: see chapter \ref{sub:get_n_vertices}
\item Counting the number of edges: see chapter \ref{sub:get_n_edges}
\item Adding a vertex: see chapter \ref{sub:add_vertex}
\item Getting all vertices: see chapter \ref{sub:get_vertices}
\item Getting all vertex descriptors: see chapter \ref{sub:get_vertex_descriptors}
\item Adding an edge: see chapter \ref{sub:add_edge}
\item Getting all edges: see chapter \ref{sub:get_edge_iterators}
\item Getting all edge descriptors: see chapter \ref{sub:get_edge_descriptors}
\end{itemize}
These functions are mostly there for completion and showing which
data types are used.

The chapter also introduces some important concepts:
\begin{itemize}
\item Vertex descriptors: see chapter \ref{sub:Vertex-descriptors}
\item Edge insertion result: see chapter \ref{sub:boost::add_edge result}
\item Edge descriptors: see chapter \ref{sub:Edge-descriptors}
\end{itemize}
After this chapter you may want to:
\begin{itemize}
\item Building graphs with named vertices: see chapter \ref{sec:Building-graphs-with-named-vertices}
\item Building graphs with bundled vertices: see chapter \ref{sec:Building-graphs-with-bundled-vertices}
\item Building graphs with custom vertices: see chapter \ref{sec:Building-graphs-with-custom-properties}
\item Building graphs with a graph name: see chapter \ref{sec:Building-graphs-with-a-graph-name}
\end{itemize}

\subsection{Creating an empty (directed) graph\label{sub:create_empty_directed_graph}\index{Create an empty directed graph}\index{Empty directed graph, create}}

Let's create an empty graph!

Algorithm \ref{alg:create_empty_directed_graph} shows the function
to create an empty graph. 

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_graph.impl}

\caption{Creating an empty (directed) graph\index{Create empty directed graph}\label{alg:create_empty_directed_graph}}
\end{algorithm}


The code consists out of an \#include and a function definition. The
\#include\index{#include@\#include} tells the compiler to read the
header file 'adjacency\_list.hpp'. A header file\index{header file}
(often with a '.h' or '.hpp' extension) contains class and functions
declarations and/or definitions. The header file 'adjacency\_list.hpp'
contains the boost::adjacency\_list class definition. Without including
this file, you will get compile errors like 'definition of boost::adjacency\_list
unknown'%
\footnote{In practice, these compiler error messages will be longer, bordering
the unreadable%
}. The function 'create\_empty\_directed\_graph' has:
\begin{itemize}
\item a return type: The return type is 'boost::adjacency\_list<>', that
is a 'boost::adjacency\_list with all template arguments set at their
defaults
\item a noexcept specification\index{noexcept specification}: the function
should not throw%
\footnote{if the function would throw because it cannot allocate this little
piece of memory, you are already in big trouble%
}, so it is preferred to mark it noexcept\index{noexcept} (\cite{stroustrup2013}
chapter 13.7).
\item a function body: all the function body does is implicitly create its
return type by using the '\{\}'. An alternative syntax would be 'return
boost::adjacency\_list<>()', which is needlessly longer
\end{itemize}
Algorithm \ref{alg:create_empty_directed_graph_demo} demonstrates
the 'create\_empty\_directed\_graph' function. Note that it includes
a header file with the same name as the function%
\footnote{I do not think it is important to have creative names%
} first, to be able to use it. 'auto' is used, as this is preferred
over explicit type declarations (\cite{stroustrup2013} chapter 31.6).
The keyword 'auto'\index{auto} lets the compiler figure out the type
itself.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_graph_demo.impl}

\caption{Demonstration of 'create\_empty\_directed\_graph'\label{alg:create_empty_directed_graph_demo}}
\end{algorithm}


Congratulations, you've just created a boost::adjacency\_list\index{boost::adjacency_list@boost::adjacency\_list}
with its default template arguments. The boost::adjacency\_list is
the most commonly used graph type, the other is the boost::adjacency\_matrix\index{boost::adjacency_matrix@boost::adjacency\_matrix}.
We do not do anything with it yet, but still, you've just created
a graph, in which:
\begin{itemize}
\item The out edges and vertices are stored in a std::vector\index{std::vector}
\item The edges have a direction
\item The vertices, edges and graph have no properties
\item The edges are stored in a std::list\index{std::list}
\end{itemize}
It stores its edges, out edges and vertices in a two different STL\index{STL}%
\footnote{Standard Template Library, the standard library%
} containers. std::vector\index{std::vector} is the container you
should use by default (\cite{stroustrup2013} chapter 31.6, \cite{sutter_and_alexandrescu2004}
chapter 76), as it has constant time look-up and back insertion. The
std::list\index{std::list} is used for storing the edges, as it is
better suited at inserting elements at any position.

I use const\index{const} to store the empty graph as we do not modify
it. Correct use of const is called const-correct. Prefer to be const-correct\index{const-correctness}
(\cite{stroustrup1997} chapter 7.9.3, \cite{stroustrup2013} chapter
12.7, \cite{meyers2005effective} item 3, \cite{hollingworth2000cpp_builder_dev_guide}
chapter 3, \cite{sutter_and_alexandrescu2004} item 15, \cite{cline1998cpp_faqs}
FAQ 14.05, \cite{eckel2002thinking_cpp} item 8, \cite{lakos1996large}
9.1.6). 


\subsection{Creating an empty undirected graph\label{sub:create_empty_undirected_graph}\index{Create an empty graph}\index{Empty graph, create}}

Let's create another empty graph! This time, we even make it undirected!

Algorith \ref{alg:create_empty_undirected_graph} shows how to create
an undirected graph.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_graph.impl}

\caption{Creating an empty undirected graph\index{Create empty undirected graph}\label{alg:create_empty_undirected_graph}}
\end{algorithm}


This algorith differs from the 'create\_empty\_directed\_graph' function
(algoritm \ref{alg:create_empty_directed_graph}) in that there are
three template arguments that need to be specified in the creation
of the boost::adjancency\_list:
\begin{itemize}
\item the first 'boost::vecS'\index{boost::vecS}: select (that is what
the 'S\index{S}' means) that out edges are stored in a std::vector.
This is the default way.
\item the second 'boost::vecS'\index{boost::vecS}: select that the graph
vertices are stored in a std::vector. This is the default way.
\item 'boost::undirectedS'\index{boost::undirectedS}: select that the graph
is undirected. This is all we needed to change. By default, this argument
is boost::directed \index{boost::directedS}
\end{itemize}
Algorithm \ref{alg:create_empty_undirected_graph_demo} demonstrates
the 'create\_empty\_undirected\_graph' function.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_graph_demo.impl}

\caption{Demonstration of 'create\_empty\_undirected\_graph'\label{alg:create_empty_undirected_graph_demo}}
\end{algorithm}


Congratulations, with algorithm \ref{alg:create_empty_undirected_graph_demo},
you've just created an undirected graph in which:
\begin{itemize}
\item The out edges and vertices are stored in a std::vector
\item The graph is undirected
\item Vertices, edges and graph have no properties
\item Edges are stored in a std::list 
\end{itemize}

\subsection{Counting the number of vertices\label{sub:get_n_vertices}\index{Vertices, counting}\index{Counting the number of vertices}\index{Number of vertices, get}}

Let's count all zero vertices of an empty graph!

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_n_vertices.impl}

\caption{Count the number of vertices\index{Get n vertices}\label{alg:get_n_vertices}}
\end{algorithm}


The function 'get\_n\_vertices' takes the result of boost::num\_vertices\index{boost::num_vertices@boost::num\_vertices},
converts it to int and checks if there was conversion error. We do
so, as one should prefer using signed data types over unsigned ones
in an interface (\cite{lakos1996large} chapter 9.2.2). To do so,
in the function body its first stament, the unsigned long\index{unsigned long}
produced by boost::num\_vertices\index{boost::num_vertices@boost::num\_vertices}
get converted to an int using a static\_cast\index{static_cast@static\_cast}.
Using an unsigned integer over a (signed) integer for the sake of
gaining that one more bit (\cite{stroustrup1997} chapter 4.4) should
be avoided. The integer 'n' is initialized using list-initialization,
which is preferred over the other initialization syntaxes (\cite{stroustrup2013}
chapter 17.7.6). 

The assert checks if the conversion back to unsigned long re-creates
the original value, to check if no information has been lost. If information
is lost, the program crashes. Use assert\index{assert} extensively
(\cite{stroustrup1997} chapter 24.5.18, \cite{stroustrup2013} chapter
30.5, \cite{sutter_and_alexandrescu2004} chapter 68, \cite{mcconnell2004code}
chapter 8.2, \cite{liberty2001sams} hour 24, \cite{lakos1996large}
chapter 2.6).

The function 'get\_n\_vertices' is demonstrated in algorithm \ref{alg:get_n_vertices_demo},
to measure the number of vertices of both the directed and undirected
graph we are already able to create.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_n_vertices_demo.impl}

\caption{Demonstration of the 'get\_n\_vertices' function\label{alg:get_n_vertices_demo}}
\end{algorithm}


Note that the type of graph does not matter here. One can count the
number of vertices of every graph, as all graphs have vertices. Boost.Graph
is very good at detecting operations that are not allowed, during
compile time.


\subsection{Counting the number of edges\label{sub:get_n_edges}\index{Edges, counting}\index{Counting the number of edges}\index{Number of edges, get}}

Let's count all zero edges of an empty graph!

This is very similar to the previous chapter, only it uses boost::num\_edges\index{boost::num_edges@boost::num\_edges}
instead:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_n_edges.impl}

\caption{Count the number of edges\index{Get n edges}\label{alg:get_n_edges}}
\end{algorithm}


This code is similar to the 'get\_n\_vertices' function (algorithm
\ref{alg:get_n_vertices}, see rationale there) except 'boost::num\_edges'\index{boost::num_edges@boost::num\_edges}
is used, instead of 'boost::num\_vertices', which also returns an
unsigned long.

The function 'get\_n\_edges' is demonstrated in algorithm \ref{alg:get_n_edges_demo},
to measure the number of edges of an empty directed and undirected
graph.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_n_edges_demo.impl}

\caption{Demonstration of the 'get\_n\_edges' function\label{alg:get_n_edges_demo}}
\end{algorithm}



\subsection{Adding a vertex\label{sub:add_vertex}\index{Add a vertex}\index{Vertex, add}}

Empty graphs are nice, now its time to add a vertex!

To add a vertex to a graph, the boost::add\_vertex\index{boost::add_vertex@boost::add\_vertex}
function is used as shows in algorithm \ref{alg:add_vertex}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_vertex.impl}

\caption{Adding a vertex to a graph\index{Add vertex}\label{alg:add_vertex}}
\end{algorithm}


The static\_assert\index{static_assert@static\_assert} at the top
of the function checks during compiling if the function is called
with a non-const graph. One can freely omit this static\_assert: you
will get a compiler error anyways, be it a less helpful one.

Note that boost::add\_vertex (in the 'add\_vertex' function) returns
a vertex descriptor, which is ignored for now. Vertex descriptors
are looked at in more details at the chapter \ref{sub:Vertex-descriptors},
as we need these to add an edge. To allow for this already, 'add\_vertex'
also returns a vertex descriptor. 

Algorithm \ref{alg:add_vertex_demo} shows how to add a vertex to
a directed and undirected graph.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_vertex_demo.impl}

\caption{Demonstration of the 'add\_vertex' function\label{alg:add_vertex_demo}}
\end{algorithm}


This demonstration code creates two empty graphs, adds one vertex
to each and then asserts that the number of vertices in each graph
is one. This works for both types of graphs, as all graphs have vertices.


\subsection{Vertex descriptors\label{sub:Vertex-descriptors}\index{Vertex descriptor}}

A vertex descriptor is a handle to a vertex within a graph. 

Vertex descriptors can be obtained by dereferencing a vertex iterator
(see chapter \ref{sub:get_vertex_descriptors}). To do so, we first
obtain some vertex iterators in chapter \ref{sub:get_vertices}). 

Vertex descriptors are used to:
\begin{itemize}
\item add and edge between two vertices, see chapter \ref{sub:add_edge}
\item obtain properties of vertex a vertex, for example the vertex its out
degrees (chapter \ref{sub:get_vertex_out_degrees}), the vertex its
name (chapter \ref{sub:get_vertex_names}), or a custom vertex property
(chapter \ref{sub:get_vertex_my_vertexes})
\end{itemize}
In this tutorial, vertex descriptors have named prefixed with 'vd\_'\index{vd_@vd\_},
for example 'vd\_1'.


\subsection{Get the vertex iterators\label{sub:get_vertices}\index{Vertex iterator}\index{Vertex iterators, get}\index{Get vertex iterators}}

You cannot get the vertices. This may sound unexpected, as it must
be possible to work on the vertices of a graph. Working on the vertices
of a graph is done throught these steps:
\begin{itemize}
\item Obtain a vertex iterator pair from the graph
\item Dereferencing a vertex iterator to obtain a vertex descriptor
\end{itemize}
'vertices'\index{vertices} (not 'boost::vertices' \index{boost::vertices does not exist})
is used to obtain a vertex iterator pair\index{Vertex iterator pair},
as shown in algorithm \ref{alg:get_vertex_iterators}. The first vertex
iterator\index{Vertex iterator} points to the first vertex (its descriptor,
to be precise), the second points to beyond the last vertex (its descriptor,
to be precise). In this tutorial, vertex iterator pairs have named
prefixed with 'vip\_'\index{vip_@vip\_}, for example 'vip\_1'.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_iterators.impl}

\caption{Get the vertex iterators of a graph\index{Get vertices}\label{alg:get_vertex_iterators}}
\end{algorithm}


This is a somewhat trivial function, as it forwards the function call
to 'vertices'\index{vertices} (not 'boost::vertices' \index{boost::vertices does not exist}).

These vertex iterators can be dereferenced to obtain the vertex descriptors.
Note that 'get\_vertex\_iterators' will not be used often in isolation:
usually one obtains the vertex descriptors immediatly. Just for your
reference, algorithm \ref{alg:get_vertex_iterators_demo} demonstrates
of the 'get\_vertices' function, by showing that the vertex iterators
of an empty graph point to the same location.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_iterators_demo.impl}

\caption{Demonstration of 'get\_vertex\_iterators'\label{alg:get_vertex_iterators_demo}}
\end{algorithm}



\subsection{Get all vertex descriptors\label{sub:get_vertex_descriptors}\index{Vertex descriptors, get}\index{Get vertex descriptors}}

Vertex descriptors are the way to manipulate those vertices. Let's
go get the all!

Vertex descriptors are obtained from dereferencing vertex iterators.
Algorithm \ref{alg:get_vertex_descriptors} shows how to obtain all
vertex descriptors from a graph.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_descriptors.impl}

\caption{Get all vertex descriptors of a graph\index{Get vertex descriptors}\label{alg:get_vertex_descriptors}}
\end{algorithm}


This is the first more complex piece of code. In the first lines,
some 'using' statements allow for shorter type names%
\footnote{which may be necessary just to create a tutorial with code snippets
that are readable%
}. 

The std::vector to serve as a return value is created at the needed
size, which is the number of vertices. 

The function 'vertices'\index{vertices} (not boost::vertices\index{boost::vertices does not exist}!)
returns a vertex iterator pair. These iterators are used by std::copy
to iterator over. std::copy\index{std::copy} is an STL algorithm
to copy a half-open range. Prefer algorithm calls over hand-written
for-loops (\cite{stroustrup1997} chapter 18.12.1, \cite{meyers2005effective}
item 43).

In this case, we copy all vertex descriptors in the range produced
by 'vertices' to the std::vector.

This function will not be used in practice: one iterates over the
vertices directly instead, saving the cost of creating a std::vector.
This function is only shown as an illustration.

Algorithm \ref{alg:get_vertex_descriptors_demo} demonstrates that
an empty graph has no vertex descriptors:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_descriptors_demo.impl}

\caption{Demonstration of 'get\_vertex\_descriptors'\label{alg:get_vertex_descriptors_demo}}
\end{algorithm}


Because all graphs have vertices and thus vertex descriptors, the
type of graph is unimportant for this code to compile.


\subsection{Add an edge\label{sub:add_edge}\index{Add an edge}\index{Edge, add}}

To add an edge to a graph, two vertex descriptors are needed. A vertex
descriptor\index{Vertex descriptor} is a handle to the vertex within
a graph (vertex descriptors are looked at in more details in chapter
\ref{sub:Vertex-descriptors}). Algorithm \ref{alg:add_edge} adds
two vertices to a graph, and connects these two using boost::add\_edge\index{boost::add_edge@boost::add\_edge}: 

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_edge.impl}

\caption{Adding (two vertices and) an edge to a graph\index{add_edge@add\_edge}\label{alg:add_edge}}
\end{algorithm}


Algorithm \ref{alg:add_edge} shows how to add an isolated edge to
a graph (instead of allowing for graphs with higher connectivities).
First, two vertices are created, using the function 'boost::add\_vertex'.
'boost::add\_vertex' returns a vertex descriptor (which I prefix with
'vd'\index{vd}), both of which are stored. The vertex descriptors
are used to add an edge to the graph, using 'boost::add\_edge'\index{boost::add_edge@boost::add\_edge}.
'boost::add\_edge'\index{boost::add_edge@boost::add\_edge} returns
a std::pair\index{std::pair}, consisting of an edge descriptor
and a boolean success indicator. The success of adding the edge is
checked by an assert statement. Here we assert\index{assert} that
this insertion was successfull. Insertion can fail if an edge is already
present and duplicates are not allowed.

A demonstration of add\_edge is shown in algorith \ref{alg:add_edge_demo},
in which an edge is added to both a directed and undirected graph,
after which the number of edges and vertices is checked.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_edge_demo.impl}

\caption{Demonstration of 'add\_edge'\label{alg:add_edge_demo}}
\end{algorithm}


The graph type is unimportant: as all graph types have vertices and
edges, edges can be added without possible compile problems.


\subsection{boost::add\_edge result\label{sub:boost::add_edge result}\index{boost::add_edge result@boost::add\_edge result}}

When using the function 'boost::add\_edge', a 'std::pair<edge\_descriptor,bool>'
is returned. It contains both the edge descriptor (see chapter \ref{sub:Edge-descriptors})
and a boolean, which indicates insertion success.

In this tutorial, boost::add\_edge results have named prefixed with
'aer\_'\index{aer_@aer\_}, for example 'aer\_1'.


\subsection{Getting the edge iterators\label{sub:get_edge_iterators}}

You cannot get the edges directly. Instead, working on the edges of
a graph is done throught these steps:
\begin{itemize}
\item Obtain an edge iterator pair from the graph
\item Dereference an edge iterator to obtain an edge descriptor
\end{itemize}
'edges\index{edges}' (not boost::edges\index{boost::edges does not exist}!)
is used to obtain an edge iterator pair\index{Edge iterator pair}.
The first edge iterator\index{Edge iterator} points to the first
edge (its descriptor, to be precise), the second points to beyond
the last edge (its descriptor, to be precise). In this tutorial, edge
iterator pairs have named prefixed with 'eip\_'\index{eip_@eip\_},
for example 'eip\_1'. Algoritm \ref{alg:get_edge_iterators} shows
how to obtain these:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_iterators.impl}

\caption{Get the edge iterators of a graph\index{Get edge iterators}\label{alg:get_edge_iterators}}
\end{algorithm}


This is a somewhat trivial function, as all it does is forward to
function call to 'edges' (not boost::edges\index{boost::edges does not exist}!)
These edge iterators can be dereferenced to obtain the edge descriptors.
Note that this function will not be used often in isolation: usually
one obtains the edge descriptors immediatly.

Algorithm \ref{alg:get_edge_iterators_demo} demonstrates 'get\_edge\_iterators'
by showing that both iterators of the edge iterator pair point to
the same location, when the graph is empty.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_iterators_demo.impl}

\caption{Demonstration of 'get\_edge\_iterators'\label{alg:get_edge_iterators_demo}}
\end{algorithm}



\subsection{Edge descriptors\label{sub:Edge-descriptors}\index{Edge descriptor}}

An edge descriptor is a handle to an edge within a graph. They are
similar to vertex descriptors (chapter \ref{sub:Vertex-descriptors}). 

Edge descriptors are used to obtain the name, or other properties,
of an edge

In this tutorial, edge descriptors have named prefixed with 'ed\_'\index{ed_@ed\_},
for example 'ed\_1'.


\subsection{Get all edge descriptors\label{sub:get_edge_descriptors}\index{Edge descriptors, get}\index{Get edge descriptors}}

Obtaining all edge descriptors is similar to obtaining all vertex
descriptors (algorithm \ref{alg:get_vertex_descriptors}), as shown
in algorithm \ref{alg:get_edge_descriptors}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_descriptors.impl}

\caption{Get all edge descriptors of a graph\index{Get edge descriptors}\label{alg:get_edge_descriptors}}
\end{algorithm}


The only difference is that instead of the function 'vertices' (not
boost::vertices\index{boost::vertices does not exist}!), 'edges'\index{edges}
(not boost::edges\index{boost::edges does not exist}!) is used. 

Algorithm \ref{alg:get_edge_descriptors_demo} demonstrates the 'get\_edge\_descriptor',
by showing that empty graphs do not have any edge descriptors.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_descriptors_demo.impl}

\caption{Demonstration of get\_edge\_descriptors\label{alg:get_edge_descriptors_demo}}
\end{algorithm}



\subsection{Creating a directed graph\label{sub:create_markov_chain_graph}\index{Create directed graph}\index{Directed graph, create}}

Finally, we are going to create a directed non-empty graph! 


\subsubsection{Graph}

This directed graph is a two-state Markov chain, with two vertices
and four edges, as depicted in figure \ref{fig:markov_chain}:

\begin{figure}[H]
\begin{tikzpicture}   
\tikzset{ 
  VertexStyle/.append style = {draw=black,fill=white,shape=circle,text=white},
  EdgeStyle/.append style = {->, bend left} }
\SetGraphUnit{5}
\Vertex{A}   
\EA(A){B}   
\Edge[](A)(B)   
\Edge[](B)(A)   
\Loop[dist = 4cm, dir = NO](A.west)
\Loop[dist = 4cm, dir = SO](B.east)
\end{tikzpicture}

\caption{The two-state Markov chain\label{fig:markov_chain}}
\end{figure}


Note that directed graphs can have edges that start and end in the
same vertex. These are called self-loops.


\subsubsection{Function to create such a graph}

To create this two-state Markov chain, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_markov_chain.impl}

\caption{Creating the two-state Markov chain as depicted in figure \ref{fig:markov_chain}\index{Create Markov chain}\label{alg:create_markov_chain_graph}}
\end{algorithm}


Instead of typing the complete type, we call the 'create\_empty\_directed\_graph'
function, and let auto figure out the type. The vertex descriptors
(see chapter \ref{sub:Vertex-descriptors}) created by two boost::add\_vertex\index{boost::add_vertex@boost::add\_vertex}
calls are stored to add an edge to the graph. Then boost::add\_edge\index{boost::add_edge@boost::add\_edge}
is called four times. Every time, its return type (see chapter \ref{sub:boost::add_edge result})
is checked for a successfull insertion.

Note that the graph lacks all properties: nodes do not have names,
nor do edges.


\subsubsection{Creating such a graph}

Algorithm \ref{create_markov_chain_demo} demonstrates the 'create\_markov\_chain\_graph'
function and checks if it has the correct amount of edges and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_markov_chain_demo.impl}

\caption{Demonstration of the 'create\_markov\_chain' \label{create_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_markov_chain.dot}}

Running a bit ahead, this graph can be converted to a .dot file using
the 'save\_graph\_to\_dot' function (algorithm \ref{alg:save_graph_to_dot}).
The .dot file created is displayed in algorithm \ref{alg:create_markov_chain.dot}:

\begin{algorithm}[H]
\verbatiminput{create_markov_chain.dot}

\caption{.dot file created from the 'create\_markov\_chain\_graph' function
(algorithm \ref{alg:create_markov_chain_graph}), converted from graph
to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_markov_chain.dot}}
\end{algorithm}


From the .dot file one can already see that the graph is directed,
because:
\begin{itemize}
\item The first word, 'digraph', denotes a directed graph (where 'graph'
would have indicated an undirectional graph)
\item The edges are written as '->' (where undirected connections would
be written as '--')
\end{itemize}

\subsubsection{The .svg file produced\label{sub:create_markov_chain.svg}}

The .svg file of this graph is shown in figure \ref{fig:create_markov_chain.svg}:

\begin{figure}[H]
\includegraphics{create_markov_chain}

\caption{.svg file created from the 'create\_markov\_chain' function (algorithm
\ref{alg:create_markov_chain_graph}) its .dot file and converted
from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_markov_chain.svg}}
\end{figure}


This figure shows that the graph in directed, as the edges have arrow
heads. The vertices display the node index, which is the default behavior.


\subsection{Creating $K_{2}$, a fully connected undirected graph with two vertices\label{sub:create_k2_graph}\index{Create $K_{2}$}\index{$K_{2}$, create}}

Finally, we are going to create an undirected non-empty graph!


\subsubsection{Graph}

To create a fully connected undirected graph with two vertices (also
called $K_{2}$), one needs two vertices and one (undirected) edge,
as depicted in figure \ref{fig:k2_graph}.

\begin{figure}[H]
\tikz 
\draw[thick] 
  (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 
    -- (5,1) node[draw=black,fill=white,shape=circle,text=white] {} 
;

\caption{$K_{2}$: a fully connected undirected graph with two vertices\label{fig:k2_graph}}
\end{figure}



\subsubsection{Function to create such a graph}

To create $K_{2}$, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_k2_graph.impl}

\caption{Creating $K_{2}$ as depicted in figure \ref{fig:k2_graph}\index{Create $K_{2}$ graph}\label{alg:create_k2_graph}}
\end{algorithm}


This code is very similar to the 'add\_edge' function (algorithm \ref{alg:add_edge}).
Instead of typing the graph its type, we call the 'create\_empty\_undirected\_graph'
function and let auto figure it out. The vertex descriptors (see chapter
\ref{sub:Vertex-descriptors}) created by two boost::add\_vertex\index{boost::add_vertex@boost::add\_vertex}
calls are stored to add an edge to the graph. From boost::add\_edge\index{boost::add_edge@boost::add\_edge}
its return type (see chapter \ref{sub:boost::add_edge result}), it
is only checked that insertion has been successfull.

Note that the graph lacks all properties: nodes do not have names,
nor do edges.


\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_k2_graph_demo} demonstrates how to 'create\_k2\_graph'
and checks if it has the correct amount of edges and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_k2_graph_demo.impl}

\caption{Demonstration of 'create\_k2\_graph' \label{alg:create_k2_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_k2.dot}}

Running a bit ahead, this graph can be converted to the .dot file
as shown in algorithm \ref{alg:create_k2_graph.dot}:

\begin{algorithm}[H]
\verbatiminput{create_k2_graph.dot}

\caption{.dot file created from the 'create\_k2\_graph' function (algorithm
\ref{alg:create_k2_graph}), converted from graph to .dot file using
algorithm \ref{alg:save_graph_to_dot}\label{alg:create_k2_graph.dot}}
\end{algorithm}


From the .dot file one can already see that the graph is undirected,
because:
\begin{itemize}
\item The first word, 'graph', denotes an undirected graph (where 'digraph'
would have indicated a directional graph)
\item The edge between 0 and 1 is written as '--' (where directed connections
would be written as '->', '<-' or '<>')
\end{itemize}

\subsubsection{The .svg file produced\label{sub:create_k2.svg}}

Continuing to running a bit ahead, this .dot file can be converted
to the .svg as shown in figure \ref{fig:create_k2_graph.svg}:

\begin{figure}[H]
\includegraphics{create_k2_graph}

\caption{.svg file created from the 'create\_k2\_graph' function (algorithm
\ref{alg:create_k2_graph}) its .dot file, converted from .dot file
to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_k2_graph.svg}}
\end{figure}


Also this figure shows that the graph is undirected, otherwise the
edge would have one or two arrow heads. The vertices display the node
index, which is the default behavior.


\subsection{\textifsymbol[ifgeo]{100} Creating $K_{3}$, a fully connected undirected
graph with three vertices\label{sub:create_k3_graph}\index{Create $K_{3}$}\index{$K_{3}$, create}}

This is an extension of the previous chapter


\subsubsection{Graph}

To create a fully connected undirected graph with three vertices (also
called $K_{3}$), one needs three vertices and three (undirected) edges,
as depicted in figure \ref{fig:create_k3_graph}.

\begin{figure}[H]
\tikz 
\draw[thick] 
  (2,4) node[draw=black,fill=white,shape=circle,text=white] {} 
   -- (3,2) node[anchor=west] {} 
   -- (4,0) node[draw=black,fill=white,shape=circle,text=white] {} 
   -- (2,0) node[anchor=north] {} 
   -- (0,0) node[draw=black,fill=white,shape=circle,text=white] {} 
   -- (1,2) node[anchor=east] {} 
   -- (2,4)
;

\caption{$K_{3}$: a fully connected graph with three edges and vertices \label{fig:create_k3_graph}}
\end{figure}



\subsubsection{Function to create such a graph}

To create $K_{3}$, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_k3_graph.impl}

\caption{Creating $K_{3}$ as depicted in figure \ref{fig:create_k3_graph}\index{Create $K_{3}$ graph}\label{alg:create_k3_graph}}
\end{algorithm}



\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_k3_graph_demo} demonstrates how to 'create\_k3\_graph'
and checks if it has the correct amount of edges and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_k3_graph_demo.impl}

\caption{Demonstration of 'create\_k3\_graph' \label{alg:create_k3_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_k3_graph.dot}}

This graph can be converted to the .dot file as shown in algorithm
\ref{alg:create_k3_graph.dot}:

\begin{algorithm}[H]
\verbatiminput{create_k3_graph.dot}

\caption{.dot file created from the 'create\_k3\_graph' function (algorithm
\ref{alg:create_k3_graph}), converted from graph to .dot file using
algorithm \ref{alg:save_graph_to_dot}\label{alg:create_k3_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced\label{sub:create_k3.svg}}

Continuing to running a bit ahead, this .dot file can be converted
to the .svg as shown in figure \ref{fig:create_k3_graph.svg}:

\begin{figure}[H]
\includegraphics{create_k3_graph}

\caption{.svg file created from the 'create\_k3\_graph' function (algorithm
\ref{alg:create_k3_graph}) its .dot file, converted from .dot file
to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_k3_graph.svg}}
\end{figure}



\subsection{\textifsymbol[ifgeo]{100} Creating a path graph\label{sub:create_path_graph}\index{Create path graph}\index{Path graph, create}}

A path graph is a linear graph without any branches


\subsubsection{Graph}

Here I show a path graph with four vertices (see figure \ref{fig:create_path_graph}):

\begin{figure}[H]
\begin{tikzpicture}   
\tikzset{ 
  VertexStyle/.append style = {draw=black,fill=white,shape=circle,text=white}
}
\SetGraphUnit{4}
\Vertex{A}   
\EA(A){B}   
\EA(B){C}   
\EA(C){D}   
\Edge[](A)(B)   
\Edge[](B)(C)   
\Edge[](C)(D)   
\end{tikzpicture}

\caption{A path graph with four vertices \label{fig:create_path_graph}}
\end{figure}



\subsubsection{Function to create such a graph}

To create a path graph, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_path_graph.impl}

\caption{Creating a path graph as depicted in figure \ref{fig:create_path_graph}\index{Create path graph}\label{alg:create_path_graph}}
\end{algorithm}



\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_path_graph_demo} demonstrates how to 'create\_path\_graph'
and checks if it has the correct amount of edges and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_path_graph_demo.impl}

\caption{Demonstration of 'create\_path\_graph' \label{alg:create_path_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_path_graph.dot}}

This graph can be converted to the .dot file as shown in algorithm
\ref{alg:create_path_graph.dot}:

\begin{algorithm}[H]
\verbatiminput{create_path_graph_4.dot}

\caption{.dot file created from the 'create\_path\_graph' function (algorithm
\ref{alg:create_path_graph}), converted from graph to .dot file using
algorithm \ref{alg:save_graph_to_dot}\label{alg:create_path_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced\label{sub:create_path_graph.svg}}

The .dot file can be converted to the .svg as shown in figure \ref{fig:create_path_graph.svg}:

\begin{figure}[H]
\includegraphics{create_path_graph_4}

\caption{.svg file created from the 'create\_path\_graph' function (algorithm
\ref{alg:create_path_graph}) its .dot file, converted from .dot file
to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_path_graph.svg}}
\end{figure}



\subsection{\textifsymbol[ifgeo]{100} Creating a Petersen graph\label{sub:create_petersen_graph}\index{Create Petersen graph}\index{Petersen graph, create}}

This is an extension of the previous chapter.


\subsubsection{Graph}

To create a fully connected undirected graph with two vertices (also
called $K_{2}$), one needs two vertices and one (undirected) edge,
as depicted in figure \ref{fig:create_petersen_graph}.

\begin{figure}[H]
\includegraphics{Petersen_graph}

\caption{A Petersen graph (from \protect\url{https://en.wikipedia.org/wiki/Petersen_graph})
\label{fig:create_petersen_graph}}
\end{figure}



\subsubsection{Function to create such a graph}

To create a Petersen graph, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_petersen_graph.impl}

\caption{Creating Petersen graph as depicted in figure \ref{fig:create_petersen_graph}\index{Create Petersen graph}\label{alg:create_petersen_graph}}
\end{algorithm}



\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_petersen_graph_demo} demonstrates how to
use 'create\_petersen\_graph' and checks if it has the correct amount
of edges and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_petersen_graph_demo.impl}

\caption{Demonstration of 'create\_petersen\_graph' \label{alg:create_petersen_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_petersen_graph.dot}}

This graph can be converted to the .dot file as shown in algorithm
\ref{alg:create_petersen_graph.dot}:

\begin{algorithm}[H]
\verbatiminput{create_petersen_graph.dot}

\caption{.dot file created from the 'create\_petersen\_graph' function (algorithm
\ref{alg:create_petersen_graph}), converted from graph to .dot file
using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_petersen_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced\label{sub:create_petersen.svg}}

This .dot file can be converted to the .svg as shown in figure \ref{fig:create_petersen_graph.svg}:

\begin{figure}[H]
\includegraphics[scale=0.5]{create_petersen_graph}

\caption{.svg file created from the 'create\_petersen\_graph' function (algorithm
\ref{alg:create_petersen_graph}) its .dot file, converted from .dot
file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_petersen_graph.svg}}
\end{figure}



\section{Working on graphs without properties\label{sec:Working-on-graphs-without-properties}}

Now that we can build a graph, there are some things we can do. 
\begin{itemize}
\item Getting the vertices' out degrees: see chapter \ref{sub:get_vertex_out_degrees}
\item Create a direct-neighbour subgraph from a vertex descriptor
\item Create all direct-neighbour subgraphs from a graph
\item Saving a graph without properties to .dot file: see chapter \ref{sub:save_graph_to_dot}
\item Loading an undirected graph without properties from .dot file: see
chapter \ref{sub:load_undirected_graph_from_dot}
\item Loading a directed graph without properties from .dot file: see chapter
\ref{sub:load_directed_graph_from_dot}
\end{itemize}

\subsection{Getting the vertices' out degree\label{sub:get_vertex_out_degrees}}

Let's measure the out degree of all vertices in a graph! 

The out degree of a vertex is the number of edges that originate at
it. 

The number of connections is called the 'degree' of the vertex. There
are three types of degrees:
\begin{itemize}
\item in degree: the number of incoming connections, using 'in\_degree'\index{in_degree@in\_degree}
(not 'boost::in\_edgree'\index{boost::in_degree does not exist@boost::in\_degree does not exist})
\item out degree: the number of outgoing connections, using 'out\_degree'\index{out_degree@out\_degree}
(not 'boost::out\_edgree'\index{boost::out_degree does not exist@boost::out\_degree does not exist})
\item degree: sum of the in degree and out degree, using 'degree'\index{idegree}
(not 'boost::edgree'\index{boost::degree does not exist})
\end{itemize}
Algorithm \ref{alg:get_vertex_out_degrees} shows how to obtain these:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_out_degrees.impl}

\caption{Get the vertices' out degrees\index{Get vertex out degrees}\label{alg:get_vertex_out_degrees}}
\end{algorithm}


The structure of this algorithm is similar to 'get\_vertex\_descriptors'
(algorithm \ref{alg:get_vertex_descriptors}), except that the out
degrees from the vertex descriptors are stored. The out degree of
a vertex iterator is obtained from the function 'out\_degree'\index{out_degree@out\_degree}
(not boost::out\_degree\index{boost::out_degree does not exist@boost::out\_degree does not exist}!). 

Albeit that the $K_{2}$ graph and the two-state Markov chain are
rather simple, we can use it to demonstrate 'get\_vertex\_out\_degrees'
on, as shown in algorithm \ref{alg:get_vertex_out_degrees_demo}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_out_degrees_demo.impl}

\caption{Demonstration of the 'get\_vertex\_out\_degrees' function\label{alg:get_vertex_out_degrees_demo}}
\end{algorithm}


It is expected that $K_{2}$ has one out-degree for every vertex,
where the two-state Markov chain is expected to have two out-degrees
per vertex.


\subsection{\textifsymbol[ifgeo]{100} Is there an edge between two vertices?\label{sub:has_edge_between_vertices}}

If you have two vertex descriptors, you can check if these are connected
by an edge:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_edge_between_vertices.impl}

\caption{Check if there exists an edge between two vertices\index{Has edge between vertices}\label{alg:has_edge_between_vertices}}
\end{algorithm}


This code uses the function 'edge'\index{edge} (not boost::edge\index{boost::edge does not exist}:
it returns a pair consisting of an edge descriptor and a boolean indicating
if it is a valid edge descriptor. The boolean will be true if there
exists an edge between the two vertices and false if not.

The demo shows that there is an edge between the two vertices of a
$K_{2}$ graph, but there are no self-loops (edges that original and
end at the same vertex).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_edge_between_vertices_demo.impl}

\caption{Demonstration of the 'has\_edge\_between\_vertices' function\label{alg:has_edge_between_vertices_demo}}
\end{algorithm}



\subsection{\textifsymbol[ifgeo]{100} Get the edge between two vertices\label{sub:get_edge_between_vertices}}

If you have two vertex descriptors, you can use these to find the
edge between them.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_between_vertices.impl}

\caption{Get the edge between two vertices\index{Get edge between vertices}\label{alg:get_edge_between_vertices}}
\end{algorithm}


This code does assume that there is an edge between the two vertices.

The demo shows how to get the edge between two vertices, deleting
it, and checking for success.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_between_vertices_demo.impl}

\caption{Demonstration of the 'get\_edge\_between\_vertices' function\label{alg:get_edge_between_vertices_demo}}
\end{algorithm}



\subsection{\textifsymbol[ifgeo]{100} Create a direct-neighbour subgraph from
a vertex descriptor}

Suppose you have a vertex of interest its vertex descriptor. Let's
say you want to get a subgraph of that vertex and its direct neighbours
only. This means that all vertices of that subgraph are adjacent vertices
and that the edges go either from focal vertex to its neighbours,
or from adjacent vertex to adjacent neighbour.

Here is the 'create\_direct\_neighbour\_subgraph' code:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_direct_neighbour_subgraph.impl}

\caption{Get the direct-neighbour subgraph from a vertex descriptor\index{Create direct-neighbour subgraph}\label{alg:create_direct_neighbour_subgraph}}
\end{algorithm}


This demonstration code shows that the direct-neighbour graph of each
vertex of a K2 graphs is ... a K2 graph!

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_direct_neighbour_subgraph_demo.impl}

\caption{Demo of the 'create\_direct\_neighbour\_subgraph' function\label{alg:create_direct_neighbour_subgraph_demo}}
\end{algorithm}



\subsection{\textifsymbol[ifgeo]{100} Creating all direct-neighbour subgraphs
from a graph without properties}

Using the previous function, it is easy to create all direct-neighbour
subgraphs from a graph without properties:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_all_direct_neighbour_subgraphs.impl}

\caption{Create all direct-neighbour subgraphs from a graph without properties\index{Create all direct-neighbour subgraphs}\label{alg:create_all_direct_neighbour_subgraphs}}
\end{algorithm}


This demonstration code shows that all direct-neighbour graphs of
a K2 graphs are ... K2 graphs!

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_all_direct_neighbour_subgraphs_demo.impl}

\caption{Demo of the 'create\_all\_direct\_neighbour\_subgraphs' function\label{alg:create_all_direct_neighbour_subgraphs_demo}}
\end{algorithm}



\subsection{\textifsymbol[ifgeo]{100} Are two graphs isomorphic?\label{sub:is_isomorphic}}

You may want to check if two graphs are isomorphic. That is: if they
have the same shape.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{is_isomorphic.impl}

\caption{Check if two graphs are isomorphic\index{Is isomorphic}\label{alg:is_isomorphic}}
\end{algorithm}


This demonstration code shows that a $K_{3}$ graph is not equivalent
to a 3-vertices path graph:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{is_isomorphic_demo.impl}

\caption{Demo of the 'is\_isomorphic' function\label{alg:is_isomorphic_demo}}
\end{algorithm}



\subsection{Saving a graph to a .dot file\label{sub:save_graph_to_dot}\index{Save graph as .dot}\index{Create .dot from graph} }

Graph are easily saved to a file, thanks to Graphviz. Graphviz\index{Graphviz}
(short for Graph Visualization Software) is a package of open-source
tools for drawing graphs. It uses the DOT language for describing
graphs, and these are commonly stored in (plain-text) .dot files (I
show .dot file of every non-empty graph created, e.g. chapters \ref{sub:create_markov_chain.dot}
and \ref{sub:create_k2.dot})

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_graph_to_dot.impl}

\caption{Saving a graph to a .dot file\index{Save graph to dot}\label{alg:save_graph_to_dot}}
\end{algorithm}


All the code does is create an std::ofstream\index{std::ofstream}
(an output-to-file stream) and use boost::write\_graphviz\index{boost::write_graphviz@boost::write\_graphviz}
to write the DOT description of our graph to that stream. Instead
of 'std::ofstream', one could use std::cout\index{std::cout} (a related
output stream) to display the DOT language on screen directly.

Algorithm \ref{alg:save_graph_to_dot_demo} shows how to use the 'save\_graph\_to\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_graph_to_dot_demo.impl}

\caption{Demonstration of the 'save\_graph\_to\_dot' function\label{alg:save_graph_to_dot_demo}}
\end{algorithm}


When using the 'save\_graph\_to\_dot' function (algorithm \ref{alg:save_graph_to_dot}),
only the structure of the graph is saved: all other properties like
names are not stored. Algorithm \ref{alg:save_named_vertices_graph_to_dot}
shows how to do so.


\subsection{Loading a directed graph from a .dot\label{sub:load_directed_graph_from_dot}\index{Load directed graph from .dot}\index{Create directed graph from .dot} }

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph is loaded, as shown in algorithm
\ref{alg:load_directed_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_graph_from_dot.impl}

\caption{Loading a directed graph from a .dot file\index{Load directed graph from dot}\label{alg:load_directed_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists,
using the 'is\_regular\_file' function (algorithm \ref{alg:is_regular_file}),
after which an std::ifstream\index{std::ifstream} is opened. Then
an empty directed graph is created, which saves us writing down the
template arguments explicitly. Then, a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with the 'boost::ignore\_other\_properties'\index{boost::ignore_other_properties@boost::ignore\_other\_properties}
in its constructor (using a default constructor here results in the
run-time error 'property not found: node\_id', see chapter \ref{sub:property_not_found_node_id}).
From this and the empty graph, 'boost::read\_graphviz'\index{boost::read_graphviz@boost::read\_graphviz}
is called to build up the graph.

Algorithm \ref{alg:load_directed_graph_from_dot_demo} shows how to
use the 'load\_directed\_graph\_from\_dot' function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_graph\_from\_dot' function\label{alg:load_directed_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_markov\_chain\_graph' function (algorithm \ref{alg:create_markov_chain_graph}),
saved and then loaded. The loaded graph is then checked to be a two-state
Markov chain.


\subsection{Loading an undirected graph from a .dot file\label{sub:load_undirected_graph_from_dot}\index{Load undirected graph from .dot}\index{Create undirected graph from .dot} }

Loading an undirected graph from a .dot file is very similar to loading
a directed graph from a .dot file, as shown in chapter \ref{sub:load_directed_graph_from_dot}.
Algorithm \ref{alg:load_undirected_graph_from_dot} show how to do
so:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_graph_from_dot.impl}

\caption{Loading an undirected graph from a .dot file\index{Load undirected graph from_dot@Load undirected graph from\_dot}\label{alg:load_undirected_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:load_directed_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_graph_from_dot_demo} shows how
to use the 'load\_undirected\_graph\_from\_dot' function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_graph\_from\_dot' function\label{alg:load_undirected_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the $K_{2}$ graph is created using the
'create\_k2\_graph' function (algorithm \ref{alg:create_k2_graph}),
saved and then loaded. The loaded graph is checked to be a $K_{2}$
graph.


\section{Building graphs with named vertices\label{sec:Building-graphs-with-named-vertices}}

Up until now, the graphs created have had edges and vertices without
any property. In this chapter, graphs will be created, in which the
vertices can have a name. This name will be of the std::string data
type, but other types are possible as well. There are many more built-in
properties edges and nodes can have (see chapter \ref{sub:all_properties}
for a list).

In this chapter, we will build the following graphs:
\begin{itemize}
\item An empty directed graph that allows for vertices with names: see chapter
\ref{sub:create_empty_directed_named_vertices_graph}
\item An empty undirected graph that allows for vertices with names: see
chapter \ref{sub:create_empty_undirected_named_vertices_graph}
\item Two-state Markov chain with named vertices: see chapter \ref{sub:create_named_vertices_markov_chain}
\item $K_{2}$ with named vertices: see chapter \ref{sub:create_named_vertices_k2_graph}
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Adding a named vertex: see chapter \ref{sub:add_named_vertex}
\item Getting the vertices' names: see chapter \ref{sub:get_vertex_names}
\end{itemize}
After this chapter you may want to:
\begin{itemize}
\item Building graphs with named edges and vertices: see chapter \ref{sec:Building-graphs-with-named-edges-and-vertices}
\item Building graphs with bundled vertices: see chapter \ref{sec:Building-graphs-with-bundled-vertices}
\item Building graphs with custom vertices: see chapter \ref{sec:Building-graphs-with-custom-properties}
\item Building graphs with a graph name: see chapter \ref{sec:Building-graphs-with-a-graph-name}
\end{itemize}

\subsection{Creating an empty directed graph with named vertices\label{sub:create_empty_directed_named_vertices_graph}\index{Create an empty directed graph with named vertices}\index{Named vertices, create empty directed graph}\index{Empty directed graph with named vertices, create}}

Let's create a trivial empty directed graph, in which the vertices
can have a name:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_named_vertices_graph.impl}

\caption{Creating an empty directed graph with named vertices\index{Create empty directed named vertices graph}\label{alg:create_empty_directed_named_vertices_graph}}
\end{algorithm}


Instead of using a boost::adjacency\_list with default template argument,
we will now have to specify four template arguments, where we only
set the fourth to a non-default value.

Note there is some flexibility in this function: the data type of
the vertex names is set to std::string by default, but can be of any
other type if desired.

This graph:
\begin{itemize}
\item has its out edges stored in a std::vector (due to the first boost::vecS\index{boost::vecS})
\item has its vertices stored in a std::vector (due to the second boost::vecS\index{boost::vecS})
\item is directed (due to the boost::directedS\index{boost::directedS})
\item The vertices have one property: they have a name, which is of data
type std::string (due to the boost::property<boost::vertex\_name\_t,
std::string>\index{boost::property}\index{boost::vertex_name_t@boost::vertex\_name\_t})
\item Edges and graph have no properties
\item Edges are stored in a std::list
\end{itemize}
The boost::adjacency\_list\index{boost::adjacency_list@boost::adjacency\_list}
has a new, fourth template argument 'boost::property< boost::vertex\_name\_t,
std::string>\index{boost::property}\index{boost::vertex_name_t@boost::vertex\_name\_t}'.
This can be read as: ``vertices have the property 'boost::vertex\_name\_t',
that is of data type std::string'''. Or simply: ``vertices have
a name that is stored as a std::string''.

Algorithm \ref{alg:create_empty_directed_named_vertices_graph_demo}
shows how to create such a graph:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_named_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_directed\_named\_vertices\_graph'
function \label{alg:create_empty_directed_named_vertices_graph_demo}}
\end{algorithm}



\subsection{Creating an empty undirected graph with named vertices\label{sub:create_empty_undirected_named_vertices_graph}\index{Create an empty undirected graph with named vertices}\index{Named vertices, create empty undirected graph}\index{Empty undirected graph with named vertices, create}}

Let's create a trivial empty undirected graph, in which the vertices
can have a name:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_named_vertices_graph.impl}

\caption{Creating an empty undirected graph with named vertices\index{Create empty undirected named vertices graph}\label{alg:create_empty_undirected_named_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_named_vertices_graph},
except that the directedness (the third template argument) is undirected
(due to the boost::undirectedS\index{boost::undirectedS}). See chapter
\ref{sub:create_empty_directed_named_vertices_graph} for most of
the explanation.

Algorithm \ref{alg:create_empty_undirected_named_vertices_graph_demo}
shows how to create such a graph:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_named_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_undirected\_named\_vertices\_graph'
function \label{alg:create_empty_undirected_named_vertices_graph_demo}}
\end{algorithm}



\subsection{Add a vertex with a name\label{sub:add_named_vertex}\index{Add named vertex}\index{Named vertex, add}\index{Vertex, add named}}

Adding a vertex without a name was trivially easy (see chapter \ref{sub:add_vertex}).
Adding a vertex with a name takes slightly more work, as shown by
algorithm \ref{alg:add_named_vertex}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_named_vertex.impl}

\caption{Adding a vertex with a name\index{Add named vertex}\label{alg:add_named_vertex}}
\end{algorithm}


Instead of calling 'boost::add\_vertex' with an additional argument
containing the name of the vertex%
\footnote{I am unsure if this would have been a good interface. I am sure I
expected this interface myself. I do see a problem with multiple properties
and the order of initialization, but initialization could simply follow
the same order as the the property list.%
}, multiple things need to be done:

First, the static\_assert\index{static_assert@static\_assert} at
the top of the function checks during compiling if the function is
called with a non-const graph. One can freely omit this static\_assert:
you will get a compiler error anyways, be it a less helpful one.

When adding a new vertex to the graph, the vertex descriptor (as described
in chapter \ref{sub:Vertex-descriptors}) is stored. 

The name map is obtained from the graph using 'get'. 'get' (not boost::get
\index{boost::get does not exist}) allow to obtain a property map.
In this case, 'get(boost::vertex\_name,g)\index{get}\index{boost::vertex_name@boost::vertex\_name}'),
denotes that we want to obtain the property map associated with 'boost::vertex\_name'
from the graph. 'get' has no 'boost::' prepending it, as it lives
in the same (global) namespace the function is in. Using 'boost::get'
will not compile\index{boost::get does not exist}. 

With a name map and a vertex descriptor, the name of a vertex can
be set using 'put'\index{put} (not boost::put\index{boost::put does not exist}).
'put' is the opposite of 'get'. In this case 'put(vertex\_name\_map,
vd, vertex\_name)' is read as: in the vertex name map, look up the
spot where the vertex we have the descriptor of, and put the new vertex
name there. An alternative syntax is 'vertex\_name\_map{[}vd{]} =
vertex\_name'\index{Alternative syntax for put}\index{put, alternative syntax}.
Because 'put' is more general, it is chosen to be the preferred syntax
for this tutorial.

Using 'add\_named\_vertex' is straightforward, as demonstrated by
algorithm \ref{alg:add_named_vertex_demo}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_named_vertex_demo.impl}

\caption{Demonstration of 'add\_named\_vertex'\label{alg:add_named_vertex_demo}}
\end{algorithm}



\subsection{Getting the vertices' names\label{sub:get_vertex_names}}

When the vertices of a graph have named vertices, one can extract
them as such:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_names.impl}

\caption{Get the vertices' names\index{Get vertex names}\label{alg:get_vertex_names}}
\end{algorithm}


This code is very similar to 'get\_vertex\_out\_degrees' (algorithm
\ref{alg:get_vertex_out_degrees}), as also there we iterated through
all vertices, accessing all vertex descriptors sequentially.

The names of the vertices are obtained from a boost::property\_map
and then put into a std::vector. 

The order of the vertex names may be different after saving and loading.

When trying to get the vertices' names from a graph without vertices
with names, you will get the error 'formed reference to void' (see
chapter \ref{sub:formed_reference_to_void}).

Algorithm \ref{alg:get_vertex_names_demo} shows how to add two named
vertices, and check if the added names are retrieved as expected.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_names_demo.impl}

\caption{Demonstration of 'get\_vertex\_names'\label{alg:get_vertex_names_demo}}
\end{algorithm}



\subsection{Creating a Markov chain with named vertices\label{sub:create_named_vertices_markov_chain}\index{Create Markov chain with named vertices}\index{Markov chain with named vertices, create}}

Let's create a directed non-empty graph with named vertices! 


\subsubsection{Graph}

We extend the Markov chain of chapter \ref{sub:create_markov_chain_graph}
by naming the vertices 'Good' and 'Not bad', as depicted in figure
\ref{fig:named_vertices_markov_chain}:

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]   
\tikzstyle{every state}=[]
\node[state] (A)              {Good};   
\node[state] (B) [right of=A] {Not bad};   
\path (A) edge [bend  left] node {} (B)
      (A) edge [loop  left] node {} (A)
      (B) edge [bend  left] node {} (A)
      (B) edge [loop right] node {} (B); 
\end{tikzpicture}

\caption{A two-state Markov chain where the vertices have texts\label{fig:named_vertices_markov_chain}}
\end{figure}


The vertex names are nonsensical, but I choose these for a reason:
one name is only one word, the other has two words (as it contains
a space). This will have implications for file I/O.


\subsubsection{Function to create such a graph}

To create this Markov chain, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_vertices_markov_chain.impl}

\caption{Creating a Markov chain with named vertices as depicted in figure
\ref{fig:named_vertices_markov_chain}\index{Create named vertices Markov chain}\label{alg:create_named_vertices_markov_chain}}
\end{algorithm}


Most of the code is a repeat of algorithm \ref{alg:create_markov_chain_graph},
'create\_markov\_chain\_graph'. In the end of the function body, the
names are obtained as a boost::property\_map and set to the desired
values.


\subsubsection{Creating such a graph}

Also the demonstration code (algorithm \ref{alg:create_named_vertices_markov_chain_demo})
is very similar to the demonstration code of the 'create\_markov\_chain\_graph'
function (algorithm \ref{create_markov_chain_demo}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_vertices_markov_chain_demo.impl}

\caption{Demonstrating the 'create\_named\_vertices\_markov\_chain' function\label{alg:create_named_vertices_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_named_vertices_markov_chain.dot}}

Because the vertices now have a name, this should be visible in the
.dot file:

\begin{algorithm}[H]
\verbatiminput{create_named_vertices_markov_chain.dot}

\caption{.dot file created from the 'create\_named\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_named_vertices_markov_chain}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_named_vertices_markov_chain.dot}}
\end{algorithm}


As one can see, the names are stored as a label. Note that if a vertex
name contains a space, the name will be surrounded by quotes, for
example '1{[}label=''Not bad''{]};'.


\subsubsection{The .svg file produced\label{sub:create_named_vertices_markov_chain.svg}}

Now that the vertices have names, this should be reflected in the
.svg:

\begin{figure}[H]
\includegraphics{create_named_vertices_markov_chain}

\caption{.svg file created from the 'create\_named\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_named_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_named_vertices_markov_chain.svg}}
\end{figure}


The .svg now shows the vertex names, instead of the vertex indices.


\subsection{Creating $K_{2}$ with named vertices\label{sub:create_named_vertices_k2_graph}\index{Create $K_{2}$ with named vertices}\index{$K_{2}$ with named vertices, create}}

Let's create an undirected non-empty graph with named vertices! 


\subsubsection{Graph}

We extend $K_{2}$ of chapter \ref{sub:create_k2_graph} by naming
the vertices 'Me' and 'My computer', as depicted in figure \ref{fig:named_vertices_k2_graph}:

\begin{figure}[H]
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]   
\tikzstyle{every state}=[]
\node[state] (A)              {Me};   
\node[state] (B) [right of=A] {My computer};   
\path (A) edge [] node {} (B); 
\end{tikzpicture}

\caption{$K_{2}$: a fully connected graph with two named vertices\label{fig:named_vertices_k2_graph}}
\end{figure}



\subsubsection{Function to create such a graph}

To create $K_{2}$, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_vertices_k2_graph.impl}

\caption{Creating $K_{2}$ with named vertices as depicted in figure \ref{fig:named_vertices_k2_graph}\index{Create named vertices K2 graph}\label{alg:create_named_vertices_k2_graph}}
\end{algorithm}


Most of the code is a repeat of algorithm \ref{alg:create_k2_graph}.
In the end, the names are obtained as a boost::property\_map and set
to the desired names.


\subsubsection{Creating such a graph}

Also the demonstration code (algorithm \ref{alg:create_named_vertices_k2_graph_demo})
is very similar to the demonstration code of the 'create\_k2\_graph
function' (algorithm \ref{alg:create_k2_graph}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_vertices_k2_graph_demo.impl}

\caption{Demonstrating the 'create\_k2\_graph' function\label{alg:create_named_vertices_k2_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_named_vertices_k2.dot}}

Because the vertices now have a name, this should be visible in the
.dot file:

\begin{algorithm}[H]
\verbatiminput{create_named_vertices_k2_graph.dot}

\caption{.dot file created from the 'create\_named\_vertices\_k2' function
(algorithm \ref{alg:create_named_vertices_k2_graph}), converted from
graph to .dot file using algorithm \ref{alg:save_named_vertices_graph_to_dot}\label{alg:create_named_vertices_k2_graph.dot}}
\end{algorithm}


As one can see, the names are stored as a label. Note that if a vertex
name contains a space, the name will be surrounded by quotes, for
example '1{[}label=''My computer''{]};'.


\subsubsection{The .svg file produced\label{sub:create_named_vertices_k2_graph.svg}}

Now that the vertices have names, this should be reflected in the
.svg:

\begin{figure}[H]
\includegraphics{create_named_vertices_k2_graph}

\caption{.svg file created from the 'create\_named\_vertices\_k2\_graph' function
(algorithm \ref{alg:create_named_vertices_markov_chain}) its .dot
file, converted from .dot file to .svg using algorithm \ref{alg:save_named_vertices_graph_to_dot}\label{fig:create_named_vertices_k2_graph.svg}}
\end{figure}


The .svg now shows the vertex names, instead of the vertex indices.


\subsection{\textifsymbol[ifgeo]{100} Creating a path graph with named vertices\label{sub:create_named_vertices_path_graph}\index{Create path graph with named vertices}\index{Path graph with named vertices, create}}

Here we create a path graph with names vertices


\subsubsection{Graph}

Here I show a path graph with four vertices (see figure \ref{fig:create_named_vertices_path_graph}):

\begin{figure}[H]
\begin{tikzpicture}   
\tikzset{ 
  VertexStyle/.append style = {draw=black,fill=white,shape=circle,text=black}
}
\SetGraphUnit{4}
\Vertex{A}   
\EA(A){B}   
\EA(B){C}   
\EA(C){D}   
\Edge[](A)(B)   
\Edge[](B)(C)   
\Edge[](C)(D)   
\end{tikzpicture}

\caption{A path graph with four vertices \label{fig:create_named_vertices_path_graph}}
\end{figure}



\subsubsection{Function to create such a graph}

To create a path graph, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_vertices_path_graph.impl}

\caption{Creating a path graph as depicted in figure \ref{fig:create_named_vertices_path_graph}\index{Create named vertices path graph}\label{alg:create_named_vertices_path_graph}}
\end{algorithm}



\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_named_vertices_path_graph_demo} demonstrates
how to create a path graph with named vertices and checks if it has
the correct amount of edges and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_vertices_path_graph_demo.impl}

\caption{Demonstration of 'create\_named\_vertices\_path\_graph' \label{alg:create_named_vertices_path_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_named_vertices_path_graph.dot}}

This graph can be converted to the .dot file as shown in algorithm
\ref{alg:create_named_vertices_path_graph.dot}:

\begin{algorithm}[H]
\verbatiminput{create_named_vertices_path_graph.dot}

\caption{.dot file created from the 'create\_named\_vertices\_path\_graph'
function (algorithm \ref{alg:create_named_vertices_path_graph}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_named_vertices_path_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced\label{sub:create_path_graph.svg-1}}

The .dot file can be converted to the .svg as shown in figure \ref{fig:create_named_vertices_path_graph.svg}:

\begin{figure}[H]
\includegraphics{create_named_vertices_path_graph_4}

\caption{.svg file created from the 'create\_named\_vertices\_path\_graph'
function (algorithm \ref{alg:create_named_vertices_path_graph}) its
.dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_named_vertices_path_graph.svg}}
\end{figure}



\section{Working on graphs with named vertices\label{sec:Working-on-graphs-with-named-vertices}}

When vertices have names, this name gives a way to find a vertex and
working with it. This chapter shows some basic operations on graphs
with named vertices.
\begin{itemize}
\item Check if there exists a vertex with a certain name: chapter \ref{sub:has_vertex_with_name}
\item Find a vertex by its name: chapter \ref{sub:find_first_vertex_with_name}
\item Get a named vertex its degree, in degree and out degree: chapter:
\ref{sub:get_first_vertex_with_name_out_degree}
\item Get a vertex its name from its vertex descriptor: chapter \ref{sub:get_vertex_name}
\item Set a vertex its name using its vertex descriptor: chapter \ref{sub:set_vertex_name}
\item Setting all vertices' names: chapter \ref{sub:set_vertex_names}
\item Clear a named vertex its edges: chapter \ref{sub:clear_first_vertex_with_name}
\item Remove a named vertex: chapter \ref{sub:remove_first_vertex_with_name}
\item Removing an edge between two named vertices: chapter \ref{sub:remove_edge_between_vertices_with_names}
\item Saving an directed/undirected graph with named vertices to a .dot
file: chapter \ref{sub:save_named_vertices_graph_to_dot}
\item Loading a directed graph with named vertices from a .dot file: chapter
\ref{sub:load_directed_named_vertices_graph_from_dot}
\item Loading an undirected graph with named vertices from a .dot file:
chapter \ref{sub:load_undirected_named_vertices_graph_from_dot}
\end{itemize}
Especially the 'find\_first\_vertex\_by\_name' function (chapter \ref{sub:find_first_vertex_with_name})
is important, as it shows how to obtain a vertex descriptor, which
is used in later algorithms.


\subsection{Check if there exists a vertex with a certain name\label{sub:has_vertex_with_name}}

Before modifying our vertices, let's first determine if we can find
a vertex by its name in a graph. After obtaing a name map, we obtain
the vertex iterators, dereference these to obtain the vertex descriptors
and then compare each vertex its name with the one desired.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_vertex_with_name.impl}

\caption{Find if there is vertex with a certain name\index{Has vertex with name}\label{alg:has_vertex_with_name}}
\end{algorithm}


This function can be demonstrated as in algorithm \ref{alg:has_vertex_with_name_demo},
where a certain name cannot be found in an empty graph. After adding
the desired name, it is found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_vertex_with_name_demo.impl}

\caption{Demonstration of the 'has\_vertex\_with\_name' function\label{alg:has_vertex_with_name_demo}}
\end{algorithm}


Note that this function only finds if there is at least one vertex
with that name: it does not tell how many vertices with that name
exist in the graph.


\subsection{Find a vertex by its name\label{sub:find_first_vertex_with_name}}

Where STL functions work with iterators, here we obtain a vertex descriptor
(see chapter \ref{sub:Vertex-descriptors}) to obtain a handle to
the desired vertex. Algorithm \ref{alg:find_first_vertex_with_name}
shows how to obtain a vertex descriptor to the first (name) vertex
found with a specific name.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_vertex_with_name.impl}

\caption{Find the first vertex by its name\index{Find first vertex with name}\label{alg:find_first_vertex_with_name}}
\end{algorithm}


With the vertex descriptor obtained, one can read and modify the vertex
and the edges surrounding it. Algorithm \ref{alg:find_first_vertex_with_name_demo}
shows some examples of how to do so.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_vertex_with_name_demo.impl}

\caption{Demonstration of the 'find\_first\_vertex\_with\_name' function\label{alg:find_first_vertex_with_name_demo}}
\end{algorithm}



\subsection{Get a (named) vertex its degree, in degree and out degree\label{sub:get_first_vertex_with_name_out_degree}}

We already obtained all out degrees of all vertices in chapter \ref{sub:get_vertex_out_degrees}
by just collecting all vertex descriptors. Here, we will search for
a vertex with a certain name, obtain its vertex descriptor and find
the number of connections it has. 

With a vertex descriptor, we can read a vertex its types of degrees.
Algorithm \ref{alg:find_first_vertex_with_name} shows how to find
a vertex, obtain its vertex descriptor and then obtain the out degree
from it.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_first_vertex_with_name_out_degree.impl}

\caption{Get the first vertex with a certain name its out degree from its vertex
descriptor\index{Get first vertex with name out degree}\label{alg:get_first_vertex_with_name_out_degree}}
\end{algorithm}


Algorithm \ref{alg:get_first_vertex_with_name_out_degree_demo} shows
how to use this function.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_first_vertex_with_name_out_degree_demo.impl}

\caption{Demonstration of the 'get\_first\_vertex\_with\_name\_out\_degree'
function\label{alg:get_first_vertex_with_name_out_degree_demo}}
\end{algorithm}



\subsection{Get a vertex its name from its vertex descriptor\label{sub:get_vertex_name}}

This may seem a trivial paragraph, as chapter \ref{sub:get_vertex_names}
describes the 'get\_vertex\_names' algorithm, in which we get all
vertices' names. But it does not allow to first find a vertex of interest
and subsequently getting only that one its name.

To obtain the name from a vertex descriptor, one needs to pull out
the name map and then look up the vertex of interest.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_name.impl}

\caption{Get a vertex its name from its vertex descriptor\index{Get vertex name}\label{alg:get_vertex_name}}
\end{algorithm}


To use 'get\_vertex\_name', one first needs to obtain a vertex descriptor.
Algorithm \ref{alg:get_vertex_name_demo} shows a simple example:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_vertex_name_demo.impl}

\caption{Demonstration if the 'get\_vertex\_name' function\label{alg:get_vertex_name_demo}}
\end{algorithm}



\subsection{Set a (named) vertex its name from its vertex descriptor\label{sub:set_vertex_name}}

If you know how to get the name from a vertex descriptor, setting
it is just as easy, as shown in algorithm \ref{alg:set_vertex_name}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_vertex_name.impl}

\caption{Set a vertex its name from its vertex descriptor\index{Set vertex name}\label{alg:set_vertex_name}}
\end{algorithm}


To use 'set\_vertex\_name', one first needs to obtain a vertex descriptor.
Algorithm \ref{alg:set_vertex_name_demo} shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_vertex_name_demo.impl}

\caption{Demonstration if the 'set\_vertex\_name' function\label{alg:set_vertex_name_demo}}
\end{algorithm}



\subsection{Setting all vertices' names\label{sub:set_vertex_names}\index{Set vertices names}\index{Vertices, set names}}

When the vertices of a graph have named vertices and you want to set
all their names at once:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_vertex_names.impl}

\caption{Setting the vertices' names\index{Set vertex names}\label{alg:set_vertex_names}}
\end{algorithm}


A new function makes its appearance here: 'put'\index{put} (not 'boost::put'
\index{boost::put does not exist!}), which is the opposite of 'get'\index{get}
(not 'boost::get' \index{boost::get does not exist!})

This is not a very usefull function if the graph is complex. But for
just creating graphs for debugging, it may come in handy.


\subsection{Clear the edges of a named vertex\label{sub:clear_first_vertex_with_name}}

A vertex descriptor can be used to clear all in/out/both edges connected
to a vertex. It is necessary to remove these connections before the
vertex itself can be removed. There are three functions to remove
the edges connected to a vertex:
\begin{itemize}
\item boost::clear\_vertex\index{boost::clear_vertex@boost::clear\_vertex}:
removes all edges to and from the vertex 
\item boost::clear\_out\_edges\index{boost::clear_out_edges@boost::clear\_out\_edges}:
removes all outgoing edges from the vertex (in directed graphs only,
else you will get a 'error: no matching function for call to clear\_out\_edges',
as described in chapter \ref{sub:no_matching_function_for_call_to_clear_out_edges})
\item boost::clear\_in\_edges\index{boost::clear_in_edges@boost::clear\_in\_edges}:
removes all incoming edges from the vertex (in directed graphs only,
else you will get a 'error: no matching function for call to clear\_in\_edges',
as described in chapter \ref{sub:no_matching_function_for_call_to_clear_in_edges})
\end{itemize}
In the algorithm 'clear\_first\_vertex\_with\_name' the 'boost::clear\_vertex'
algorithm is used, as the graph used is undirectional:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{clear_first_vertex_with_name.impl}

\caption{Clear the first vertex with a certain name\index{Clear first vertex with name}\label{alg:clear_first_vertex_with_name}}
\end{algorithm}


Algorithm \ref{alg:clear_first_vertex_with_name_demo} shows the clearing
of the first named vertex found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{clear_first_vertex_with_name_demo.impl}

\caption{Demonstration of the 'clear\_first\_vertex\_with\_name' function\label{alg:clear_first_vertex_with_name_demo}}
\end{algorithm}



\subsection{Remove a named vertex\label{sub:remove_first_vertex_with_name}}

A vertex descriptor can be used to remove a vertex from a graph. It
is necessary to remove these connections (e.g. using clear\_first\_vertex\_with\_name',
algorithm \ref{alg:clear_first_vertex_with_name}) before the vertex
itself can be removed. 

Removing a named vertex goes as follows: use the name of the vertex
to get a first vertex descriptor, then call 'boost::remove\_vertex'\index{boost::remove_vertex@boost::remove\_vertex},
shown in algorithm \ref{sub:remove_first_vertex_with_name}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{remove_first_vertex_with_name.impl}

\caption{Remove the first vertex with a certain name\index{Remove first vertex with name}\label{alg:remove_first_vertex_with_name}}
\end{algorithm}


Algorithm \ref{alg:remove_first_vertex_with_name_demo} shows the
removal of the first named vertex found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{remove_first_vertex_with_name_demo.impl}

\caption{Demonstration of the 'remove\_first\_vertex\_with\_name' function\label{alg:remove_first_vertex_with_name_demo}}
\end{algorithm}


Again, be sure that the vertex removed does not have any connections!


\subsection{Removing the edge between two named vertices\label{sub:remove_edge_between_vertices_with_names}}

Instead of looking for an edge descriptor, one can also remove an
edge from two vertex descriptors (which is: the edge between the two
vertices). Removing an edge between two named vertices named edge
goes as follows: use the names of the vertices to get both vertex
descriptors, then call 'boost::remove\_edge'\index{boost::remove_edge@boost::remove\_edge}
on those two, as shown in algorithm \ref{alg:remove_edge_between_vertices_with_names}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{remove_edge_between_vertices_with_names.impl}

\caption{Remove the first edge with a certain name\index{Remove edge between vertices with names}\label{alg:remove_edge_between_vertices_with_names}}
\end{algorithm}


Algorithm \ref{alg:remove_edge_between_vertices_with_names_demo}
shows the removal of the first named edge found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{remove_edge_between_vertices_with_names_demo.impl}

\caption{Demonstration of the 'remove\_edge\_between\_vertices\_with\_names'
function\label{alg:remove_edge_between_vertices_with_names_demo}}
\end{algorithm}



\subsection{\textifsymbol[ifgeo]{100} Count the vertices with a certain name\label{sub:count_vertices_with_name}}

How often is a vertex with a certain name present? Here we'll find
out.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{count_vertices_with_name.impl}

\caption{Find the first vertex by its name\index{Find first vertex with name}\label{alg:count_vertices_with_name}}
\end{algorithm}


Here we use the STL std::count\_if\index{std::count_if@std::count\_if}
algorithm to count how many vertices have a name equal to the desired
name.

Algorithm \ref{alg:count_vertices_with_name_demo} shows some examples
of how to do so.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{count_vertices_with_name_demo.impl}

\caption{Demonstration of the 'find\_first\_vertex\_with\_name' function\label{alg:count_vertices_with_name_demo}}
\end{algorithm}



\subsection{\textifsymbol[ifgeo]{100} Are two graphs with named vertices isomorphic?\label{sub:is_named_vertices_isomorphic}}

Strictly speaking, finding isomorphisms is about the shape of the
graph, independent of vertex name, and is already done in chapter
\ref{sub:is_isomorphic}. 

Here, it is checked if two graphs with named vertices are 'label isomorphic'
(please email me a better term if you know one). That is: if they
have the same shape with the same vertex names at the same places.

To do this, there are two steps needed:
\begin{enumerate}
\item Map all vertex names to an unsigned int.
\item Compare the two graphs with that map
\end{enumerate}
Below the class 'named\_vertex\_invariant' is shown. Its std::map
maps the vertex names to an unsigned integer, which is done in the
member function 'collect\_names'. The purpose of this, is that is
is easier to compare integers than std::strings.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{named_vertex_invariant.impl}

\caption{The named\_vertex\_invariant functor\index{named_vertex_invariant@named\_vertex\_invariant}\label{alg:named_vertex_invariant}}
\end{algorithm}


To check for 'label isomorphism', multiple things need to be put in
place for 'boost::isomorphism'\index{boost::isomorphism} to work
with:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{is_named_vertices_isomorphic.impl}

\caption{Check if two graphs with named vertices are isomorphic\index{Is isomorphic}\label{alg:is_named_vertices_isomorphic}}
\end{algorithm}


This demonstration code creates three path graphs, of which two are
'label isomorphic':

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{is_named_vertices_isomorphic_demo.impl}

\caption{Demo of the 'is\_named\_vertices\_isomorphic' function\label{alg:is_named_vertices_isomorphic_demo}}
\end{algorithm}



\subsection{Saving an directed/undirected graph with named vertices to a .dot
file\label{sub:save_named_vertices_graph_to_dot}\index{Save graph with named vertices as .dot}\index{Create .dot from graph with named vertices} }

If you used the 'create\_named\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_named_vertices_k2_graph}) to produce a $K_{2}$ graph
with named vertices, you can store these names in multiple ways:
\begin{itemize}
\item Using boost::make\_label\_writer
\item Using a C++11 lambda function
\end{itemize}
I show both ways, because you may need all of them.

The created .dot file is shown at algorithm \ref{alg:create_named_vertices_k2_graph.dot}. 

You can use all characters in the vertex without problems (for example:
comma's, quotes, whitespace). This will not hold anymore for bundled
and custom vertices in later chapters.

The 'save\_named\_vertices\_graph\_to\_dot' functions below only save
the structure of the graph and its vertex names. It ignores other
edge and vertex properties.


\subsubsection{Using boost::make\_label\_writer}

The first implemention uses boost::make\_label\_writer, as shown in
algorithm \ref{alg:save_named_vertices_graph_to_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_named_vertices_graph_to_dot.impl}

\caption{Saving a graph with named vertices to a .dot file\index{Save named vertices graph to dot}\label{alg:save_named_vertices_graph_to_dot}}
\end{algorithm}


Here, the function boost::write\_graphviz\index{boost::write_graphviz@boost::write\_graphviz}
is called with a new, third argument. After collecting all names,
these are used by boost::make\_label\_writer\index{boost::make_label_writer@boost::make\_label\_writer}
to write the names as labels. 


\subsubsection{Using a C++11 lambda function}

An equivalent algorithm is algorithm \ref{alg:save_named_vertices_graph_to_dot_using_lambda}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_named_vertices_graph_to_dot_using_lambda.impl}

\caption{Saving a graph with named vertices to a .dot file using a lambda expression
\index{Save named vertices graph to dot using lambda function}\label{alg:save_named_vertices_graph_to_dot_using_lambda}}
\end{algorithm}


In this code, a lambda function is used as a third argument. 

A lambda function is an on-the-fly function that has these parts:
\begin{itemize}
\item the capture brackets '{[}{]}', to take variables within the lambda
function
\item the function argument parentheses '()', to put the function arguments
in
\item the function body '\{\}', where to write what it does
\end{itemize}
First we create a shorthand for the vertex descriptor type, that we'll
need to use a lambda function argument (in C++14 you can use auto).

We then create a vertex name map at function scope (in C++17 this
can be at lambda function scope) and pass it to the lambda function
using its capture section.

The lambda function arguments need to be two: a std::ostream\& (a
reference to a general out-stream) and a vertex descriptor. In the
function body, we get the name of the vertex the same as the 'get\_vertex\_name'
function (algorithm \ref{alg:get_vertex_name}) and stream it to the
out stream.


\subsubsection{Demonstration}

Algorithm \ref{alg:save_named_vertices_graph_to_dot_demo} shows how
to use (one of) the 'save\_named\_vertices\_graph\_to\_dot' function(s):

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_named_vertices_graph_to_dot_demo.impl}

\caption{Demonstration of the 'save\_named\_vertices\_graph\_to\_dot' function\label{alg:save_named_vertices_graph_to_dot_demo}}
\end{algorithm}


When using the 'save\_named\_vertices\_graph\_to\_dot' function (algorithm
\ref{alg:save_named_vertices_graph_to_dot}), only the structure of
the graph and the vertex names are saved: all other properties like
edge name are not stored. Algorithm \ref{alg:save_named_edges_and_vertices_graph_to_dot}
shows how to do so.


\subsection{Loading a directed graph with named vertices from a .dot\label{sub:load_directed_named_vertices_graph_from_dot}\index{Load directed graph with named vertices from .dot}\index{Create directed graph with named vertices from .dot} }

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph with named vertices is loaded,
as shown in algorithm \ref{alg:load_directed_named_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_named_vertices_graph_from_dot.impl}

\caption{Loading a directed graph with named vertices from a .dot file\index{Load directed named vertices graph from dot}\label{alg:load_directed_named_vertices_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists.
Then an empty directed graph is created. Next to this, a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with its default constructor, after which we direct the
boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
to find a 'node\_id' and 'label' in the vertex name map. From this
and the empty graph, 'boost::read\_graphviz'\index{boost::read_graphviz@boost::read\_graphviz}
is called to build up the graph.

Algorithm \ref{alg:load_directed_named_vertices_graph_from_dot_demo}
shows how to use the 'load\_directed\_graph\_from\_dot' function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_named_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_named\_vertices\_graph\_from\_dot'
function\label{alg:load_directed_named_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_named\_vertices\_markov\_chain' function (algorithm \ref{alg:create_markov_chain_graph}),
saved and then loaded. The loaded graph is checked to be a directed
graph similar to the Markov chain with the same vertex names (using
the 'get\_vertex\_names' function, algorithm \ref{alg:get_vertex_names}).


\subsection{Loading an undirected graph with named vertices from a .dot\label{sub:load_undirected_named_vertices_graph_from_dot}\index{Load undirected graph with named vertices from .dot}\index{Create undirected graph with named vertices from .dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an undirected graph with named vertices is loaded,
as shown in algorithm \ref{alg:load_undirected_named_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_named_vertices_graph_from_dot.impl}

\caption{Loading an undirected graph with named vertices from a .dot file\index{Load undirected named vertices graph from dot}\label{alg:load_undirected_named_vertices_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:load_directed_named_vertices_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_named_vertices_graph_from_dot_demo}
shows how to use the 'load\_undirected\_graph\_from\_dot' function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_named_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_graph\_from\_dot' function\label{alg:load_undirected_named_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how $K_{2}$ with named vertices is created
using the 'create\_named\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_named_vertices_k2_graph}), saved and then loaded.
The loaded graph is checked to be an undirected graph similar to $K_{2}$
, with the same vertex names (using the 'get\_vertex\_names' function,
algorithm \ref{alg:get_vertex_names}).


\section{Building graphs with named edges and vertices\label{sec:Building-graphs-with-named-edges-and-vertices}}

Up until now, the graphs created have had edges and vertices without
any property. In this chapter, graphs will be created, in which edges
vertices can have a name. This name will be of the std::string data
type, but other types are possible as well. There are many more built-in
properties edges and nodes can have (see the boost/graph/properties.hpp
file for these).

In this chapter, we will build the following graphs:
\begin{itemize}
\item An empty directed graph that allows for edges and vertices with names:
see chapter \ref{sub:create_empty_directed_named_edges_and_vertices_graph}
\item An empty undirected graph that allows for edges and vertices with
names: see chapter \ref{sub:create_empty_undirected_named_edges_and_vertices_graph}
\item Markov chain with named edges and vertices: see chapter \ref{sub:create_named_edges_and_vertices_markov_chain}
\item $K_{3}$ with named edges and vertices: see chapter \ref{sub:create_named_edges_and_vertices_k3}
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Adding an named edge: see chapter \ref{sub:add_named_edge}
\item Getting the edges' names: see chapter \ref{sub:get_edge_names}
\end{itemize}
These functions are mostly there for completion and showing which
data types are used.


\subsection{Creating an empty directed graph with named edges and vertices\label{sub:create_empty_directed_named_edges_and_vertices_graph}\index{Create an empty directed graph with named edges and vertices}\index{Named edges and vertices, create empty directed graph}\index{Empty directed graph with named edges and vertices, create}}

Let's create a trivial empty directed graph, in which the both the
edges and vertices can have a name:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_named_edges_and_vertices_graph.impl}

\caption{Creating an empty directed graph with named edges and vertices\index{Create empty directed named edges and vertices graph}\label{alg:create_empty_directed_named_edges_and_vertices_graph}}
\end{algorithm}


This graph:
\begin{itemize}
\item has its out edges stored in a std::vector (due to the first boost::vecS\index{boost::vecS})
\item has its vertices stored in a std::vector (due to the second boost::vecS\index{boost::vecS})
\item is directed (due to the boost::directedS\index{boost::directedS})
\item The vertices have one property: they have a name, that is of data
type std::string (due to the boost::property< boost::vertex\_name\_t,std::string>\index{boost::property}\index{boost::vertex_name_t@boost::vertex\_name\_t}')
\item The edges have one property: they have a name, that is of data type
std::string (due to the boost::property< boost::edge\_name\_t,std::string>\index{boost::property}\index{boost::edge_name_t@boost::edge\_name\_t}')
\item The graph has no properties
\item Edges are stored in a std::list
\end{itemize}
The boost::adjacency\_list\index{boost::adjacency_list@boost::adjacency\_list}
has a new, fifth template argument 'boost::property< boost::edge\_name\_t,std::string>\index{boost::property}\index{boost::edge_name_t@boost::edge\_name\_t}'.
This can be read as: ``edges have the property 'boost::edge\_name\_t',
that is of data type 'std::string'''. Or simply: ``edges have a
name that is stored as a std::string''.

Algorithm \ref{alg:create_empty_directed_named_edges_and_vertices_graph_demo}
shows how to create this graph. Note that all the earlier functions
defined in this tutorial keep working as expected.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_named_edges_and_vertices_graph_demo.impl}

\caption{Demonstration if the 'create\_empty\_directed\_named\_edges\_and\_vertices\_graph'
function \label{alg:create_empty_directed_named_edges_and_vertices_graph_demo}}
\end{algorithm}



\subsection{Creating an empty undirected graph with named edges and vertices\label{sub:create_empty_undirected_named_edges_and_vertices_graph}\index{Create an empty graph with named edges and vertices}\index{Named edges and vertices, create empty graph}\index{Empty graph with named edges and vertices, create}}

Let's create a trivial empty undirected graph, in which the both the
edges and vertices can have a name:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_named_edges_and_vertices_graph.impl}

\caption{Creating an empty undirected graph with named edges and vertices\index{Create empty undirected named edges and vertices graph}\label{alg:create_empty_undirected_named_edges_and_vertices_graph}}
\end{algorithm}


This graph:
\begin{itemize}
\item has its out edges stored in a std::vector (due to the first boost::vecS\index{boost::vecS})
\item has its vertices stored in a std::vector (due to the second boost::vecS\index{boost::vecS})
\item is undirected (due to the boost::undirectedS\index{boost::undirectedS})
\item The vertices have one property: they have a name, that is of data
type std::string (due to the boost::property< boost::vertex\_name\_t,std::string>\index{boost::property}\index{boost::vertex_name_t@boost::vertex\_name\_t}')
\item The edges have one property: they have a name, that is of data type
std::string (due to the boost::property< boost::edge\_name\_t,std::string>\index{boost::property}\index{boost::edge_name_t@boost::edge\_name\_t}')
\item The graph has no properties
\item Edges are stored in a std::list
\end{itemize}
The boost::adjacency\_list\index{boost::adjacency_list@boost::adjacency\_list}
has a new, fifth template argument 'boost::property< boost::edge\_name\_t,std::string>\index{boost::property}\index{boost::edge_name_t@boost::edge\_name\_t}'.
This can be read as: ``edges have the property 'boost::edge\_name\_t',
that is of data type 'std::string'''. Or simply: ``edges have a
name that is stored as a std::string''.

Algorithm \ref{alg:create_empty_undirected_named_edges_and_vertices_graph_demo}
shows how to create this graph. Note that all the earlier functions
defined in this tutorial keep working as expected.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_named_edges_and_vertices_graph_demo.impl}

\caption{Demonstration if the 'create\_empty\_undirected\_named\_edges\_and\_vertices\_graph'
function \label{alg:create_empty_undirected_named_edges_and_vertices_graph_demo}}
\end{algorithm}



\subsection{Adding a named edge\label{sub:add_named_edge}\index{Add named edge}\index{Named edge, add}}

Adding an edge with a name:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_named_edge.impl}

\caption{Add a vertex with a name\index{Add named edge}\label{alg:add_named_edge}}
\end{algorithm}


In this code snippet, the edge descriptor (see chapter \ref{sub:Edge-descriptors}
if you need to refresh your memory) when using 'boost::add\_edge\index{boost::add_edge@boost::add\_edge}'
is used as a key to change the edge its name map.

The algorithm \ref{alg:add_named_edge_demo} shows how to add a named
edge to an empty graph. When trying to add named vertices to graph
without this property, you will get the error 'formed reference to
void' (see chapter \ref{sub:formed_reference_to_void}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_named_edge_demo.impl}

\caption{Demonstration of the 'add\_named\_edge' function\label{alg:add_named_edge_demo}}
\end{algorithm}



\subsection{Getting the edges' names\label{sub:get_edge_names}}

When the edges of a graph have named vertices, one can extract them
as such:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_names.impl}

\caption{Get the edges' names\index{get_edge_names@get\_edge\_names}\label{alg:get_edge_names}}
\end{algorithm}


The names of the edges are obtained from a boost::property\_map and
then put into a std::vector. The algorithm \ref{alg:get_edge_names_demo}
shows how to apply this function. 

The order of the edge names may be different after saving and loading.

Would you dare to try to get the edges' names from a graph without
vertices with names, you will get the error 'formed reference to void'
(see chapter \ref{sub:formed_reference_to_void}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_names_demo.impl}

\caption{Demonstration of the 'get\_edge\_names' function\label{alg:get_edge_names_demo}}
\end{algorithm}



\subsection{Creating Markov chain with named edges and vertices\label{sub:create_named_edges_and_vertices_markov_chain}\index{Create Markov chain with named edges and vertices}\index{Markov chain with named edges and vertices, create}}


\subsubsection{Graph}

We build this graph:

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]   
  \tikzstyle{every state}=[]
  \node[state] (A)              {Happy};   
  \node[state] (B) [right of=A] {Not unhappy};   
  \path (A) edge [loop  left] node {Fruit       } (A)
        (A) edge [bend  left] node {No chocolate} (B)
        (B) edge [bend  left] node {Chocolate   } (A)
        (B) edge [loop right] node {Other candy } (B); 
\end{tikzpicture}

\caption{A two-state Markov chain where the edges and vertices have texts\label{fig:named_edges_and_vertices_markov_chain}}
\end{figure}



\subsubsection{Function to create such a graph}

Here is the code:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_edges_and_vertices_markov_chain.impl}

\caption{Creating the two-state Markov chain as depicted in figure \ref{fig:named_edges_and_vertices_markov_chain}\index{Create named edges and vertices Markov chain}\label{alg:create_named_edges_and_vertices_markov_chain}}
\end{algorithm}



\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_edges_and_vertices_markov_chain_demo.impl}

\caption{Demo of the 'create\_named\_edges\_and\_vertices\_markov\_chain' function
(algorithm \ref{alg:create_named_edges_and_vertices_markov_chain})\label{alg:create_named_edges_and_vertices_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_named_edges_and_vertices_markov_chain.dot}

\caption{.dot file created from the 'create\_named\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_named_edges_and_vertices_markov_chain}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_named_edges_and_vertices_markov_chain.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_named_edges_and_vertices_markov_chain}

\caption{.svg file created from the 'create\_named\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_named_edges_and_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_named_edges_and_vertices_markov_chain.svg}}
\end{figure}



\subsection{Creating $K_{3}$ with named edges and vertices\label{sub:create_named_edges_and_vertices_k3}\index{Create $K_{3}$ with named edges and vertices}\index{$K_{3}$ with named edges and vertices, create}}


\subsubsection{Graph}

We extend the graph $K_{2}$ with named vertices of chapter \ref{sub:create_named_vertices_k2_graph}
by adding names to the edges, as depicted in figure \ref{fig:named_edges_and_vertices_k3}:

\begin{figure}[H]
\tikz 
\draw[thick] 
  (2,4) node[fill=black,shape=circle,text=white] {top} 
   -- (3,2) node[anchor=west] {AB} 
   -- (4,0) node[fill=black,shape=circle,text=white] {right} 
   -- (2,0) node[anchor=north] {BC} 
   -- (0,0) node[fill=black,shape=circle,text=white] {left} 
   -- (1,2) node[anchor=east] {CA} 
   -- (2,4)
;

\caption{$K_{3}$: a fully connected graph with three named edges and vertices
\label{fig:named_edges_and_vertices_k3}}
\end{figure}



\subsubsection{Function to create such a graph}

To create $K_{3}$, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_edges_and_vertices_k3_graph.impl}

\caption{Creating $K_{3}$ as depicted in figure \ref{fig:named_edges_and_vertices_k3}\index{Create named edges and vertices K3 graph}\label{alg:create_named_edges_and_vertices_k3_graph}}
\end{algorithm}


Most of the code is a repeat of algorithm \ref{alg:create_named_vertices_k2_graph}.
In the end, the edge names are obtained as a boost::property\_map
and set. 


\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_named_edges_and_vertices_k3_graph_demo}
shows how to create the graph and measure its edge and vertex names.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_named_edges_and_vertices_k3_graph_demo.impl}

\caption{Demonstration of the 'create\_named\_edges\_and\_vertices\_k3' function\label{alg:create_named_edges_and_vertices_k3_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_named_edges_and_vertices_k3_graph.dot}}

\begin{algorithm}[H]
\verbatiminput{create_named_edges_and_vertices_k3_graph.dot}

\caption{.dot file created from the 'create\_named\_edges\_and\_vertices\_k3\_graph'
function (algorithm \ref{alg:create_named_edges_and_vertices_k3_graph}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_named_edges_and_vertices_k3_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced\label{sub:create_named_edges_and_vertices_k3_graph.svg}}

\begin{figure}[H]
\includegraphics{create_named_edges_and_vertices_k3_graph}

\caption{.svg file created from the 'create\_named\_edges\_and\_vertices\_k3\_graph'
function (algorithm \ref{alg:create_named_edges_and_vertices_k3_graph})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_named_edges_and_vertices_k3_graph.svg}}
\end{figure}



\section{Working on graphs with named edges and vertices}

Working with named edges...
\begin{itemize}
\item Check if there exists an edge with a certain name: chapter \ref{sub:has_edge_with_name}
\item Find a (named) edge by its name: chapter \ref{sub:find_first_edge_with_name}
\item Get a (named) edge its name from its edge descriptor: chapter \ref{sub:get_edge_name}
\item Set a (named) edge its name using its edge descriptor: chapter \ref{sub:set_edge_name} 
\item Remove a named edge: chapter \ref{sub:remove_first_edge_with_name}
\item Saving a graph with named edges and vertices to a .dot file: chapter
\ref{sub:save_named_edges_and_vertices_undirected_graph_to_dot}
\item Loading a directed graph with named edges and vertices from a .dot
file: chapter \ref{sub:load_directed_named_edges_and_vertices_graph_from_dot}
\item Loading an undirected graph with named edges and vertices from a .dot
file: chapter \ref{sub:load_undirected_named_edges_and_vertices_graph_from_dot}
\end{itemize}
Especially chapter \ref{sub:find_first_edge_with_name} with the 'find\_first\_edge\_by\_name'
algorithm shows how to obtain an edge descriptor, which is used in
later algorithms.


\subsection{Check if there exists an edge with a certain name\label{sub:has_edge_with_name}}

Before modifying our edges, let's first determine if we can find an
edge by its name in a graph. After obtaing a name map, we obtain the
edge iterators, dereference these to obtain the edge descriptors and
then compare each edge its name with the one desired.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_edge_with_name.impl}

\caption{Find if there is an edge with a certain name\index{Has edge with name}\label{alg:has_edge_with_name}}
\end{algorithm}


This function can be demonstrated as in algorithm \ref{alg:has_edge_with_name_demo},
where a certain name cannot be found in an empty graph. After adding
the desired name, it is found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_edge_with_name_demo.impl}

\caption{Demonstration of the 'has\_edge\_with\_name' function\label{alg:has_edge_with_name_demo}}
\end{algorithm}


Note that this function only finds if there is at least one edge with
that name: it does not tell how many edges with that name exist in
the graph.


\subsection{Find an edge by its name\label{sub:find_first_edge_with_name}}

Where STL functions work with iterators, here we obtain an edge descriptor
(see chapter \ref{sub:Edge-descriptors}) to obtain a handle to the
desired edge. Algorithm \ref{alg:find_first_edge_with_name} shows
how to obtain an edge descriptor to the first (name) edge found with
a specific name.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_edge_with_name.impl}

\caption{Find the first edge by its name\index{Find first edge by name}\label{alg:find_first_edge_with_name}}
\end{algorithm}


With the edge descriptor obtained, one can read and modify the graph.
Algorithm \ref{alg:find_first_edge_with_name_demo} shows some examples
of how to do so.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_edge_with_name_demo.impl}

\caption{Demonstration of the 'find\_first\_edge\_by\_name' function\label{alg:find_first_edge_with_name_demo}}
\end{algorithm}



\subsection{Get a (named) edge its name from its edge descriptor\label{sub:get_edge_name}}

This may seem a trivial paragraph, as chapter \ref{sub:get_edge_names}
describes the 'get\_edge\_names' algorithm, in which we get all edges'
names. But it does not allow to first find an edge of interest and
subsequently getting only that one its name.

To obtain the name from an edgedescriptor, one needs to pull out the
name map and then look up the edge of interest.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_name.impl}

\caption{Get an edge its name from its edge descriptor\index{Get edge name}\label{alg:get_edge_name}}
\end{algorithm}


To use 'get\_edge\_name', one first needs to obtain an edge descriptor.
Algorithm \ref{alg:get_edge_name_demo} shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_edge_name_demo.impl}

\caption{Demonstration if the 'get\_edge\_name' function\label{alg:get_edge_name_demo}}
\end{algorithm}



\subsection{Set a (named) edge its name from its edge descriptor\label{sub:set_edge_name}}

If you know how to get the name from an edge descriptor, setting it
is just as easy, as shown in algorithm \ref{alg:set_edge_name}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_edge_name.impl}

\caption{Set an edge its name from its edge descriptor\index{Set edge name}\label{alg:set_edge_name}}
\end{algorithm}


To use 'set\_edge\_name', one first needs to obtain an edge descriptor.
Algorithm \ref{alg:set_edge_name_demo} shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_edge_name_demo.impl}

\caption{Demonstration if the 'set\_edge\_name' function\label{alg:set_edge_name_demo}}
\end{algorithm}



\subsection{Removing the first edge with a certain name\label{sub:remove_first_edge_with_name}}

An edge descriptor can be used to remove an edge from a graph. 

Removing a named edge goes as follows: use the name of the edge to
get a first edge descriptor, then call 'boost::remove\_edge'\index{boost::remove_edge@boost::remove\_edge},
shown in algorithm \ref{alg:remove_first_vertex_with_name}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{remove_first_edge_with_name.impl}

\caption{Remove the first edge with a certain name\index{Remove first edge with name}\label{alg:remove_first_edge_with_name}}
\end{algorithm}


Algorithm \ref{alg:remove_first_edge_with_name_demo} shows the removal
of the first named edge found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{remove_first_edge_with_name_demo.impl}

\caption{Demonstration of the 'remove\_first\_edge\_with\_name' function\label{alg:remove_first_edge_with_name_demo}}
\end{algorithm}



\subsection{Saving an undirected graph with named edges and vertices as a .dot\label{sub:save_named_edges_and_vertices_undirected_graph_to_dot}\index{Save graph with name edges and vertices as .dot}\index{Create .dot from graph with named edges and vertices}}

If you used the create\_named\_edges\_and\_vertices\_k3\_graph function
(algorithm \ref{alg:create_named_edges_and_vertices_k3_graph}) to
produce a $K_{3}$ graph with named edges and vertices, you can store
these names additionally with algorithm \ref{alg:save_named_edges_and_vertices_graph_to_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_named_edges_and_vertices_graph_to_dot.impl}

\caption{Saving an undirected graph with named edges and vertices to a .dot
file\index{Save named edges and vertices graph to dot}\label{alg:save_named_edges_and_vertices_graph_to_dot}}
\end{algorithm}


If you created a graph with edges more complex than just a name, you
will still just write these to the .dot file. Chapter \ref{sub:save_custom_vertices_graph_to_dot}
shows how to write custom vertices to a .dot file.

So, the 'save\_named\_edges\_and\_vertices\_graph\_to\_dot' function
(algorithm \ref{alg:save_graph_to_dot}) saves only the structure
of the graph and its edge and vertex names.


\subsection{Loading a directed graph with named edges and vertices from a .dot\label{sub:load_directed_named_edges_and_vertices_graph_from_dot}\index{Load directed graph with named edges and vertices from .dot}\index{Create directed graph with named edges and vertices from .dot} }

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph with named edges and vertices is
loaded, as shown in algorithm \ref{alg:load_directed_named_edges_and_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_named_edges_and_vertices_graph_from_dot.impl}

\caption{Loading a directed graph with named edges and vertices from a .dot
file\index{Load directed named edges and vertices graph from dot}\label{alg:load_directed_named_edges_and_vertices_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists.
Then an empty directed graph is created. Next to this, a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with its default constructor, after which we direct the
boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
to find a 'node\_id' and 'label' in the vertex name map, 'edge\_id'
and 'label to the edge name map. From this and the empty graph, 'boost::read\_graphviz'\index{boost::read_graphviz@boost::read\_graphviz}
is called to build up the graph.

Algorithm \ref{alg:load_directed_named_edges_and_vertices_graph_from_dot_demo}
shows how to use the 'load\_directed\_graph\_from\_dot' function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_named_edges_and_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_named\_edges\_and\_vertices\_graph\_from\_dot'
function\label{alg:load_directed_named_edges_and_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_named\_edges\_and\_vertices\_markov\_chain' function (algorithm
\ref{alg:create_named_edges_and_vertices_markov_chain}), saved and
then loaded. The loaded graph is checked to be a directed graph similar
to the Markov chain with the same edge and vertex names (using the
'get\_edge\_names' function , algorithm \ref{alg:get_edge_names},
and the 'get\_vertex\_names' function, algorithm \ref{alg:get_vertex_names}).


\subsection{Loading an undirected graph with named edges and vertices from a
.dot\label{sub:load_undirected_named_edges_and_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an undirected graph with named edges and vertices
is loaded, as shown in algorithm \ref{alg:load_undirected_named_edges_and_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_named_edges_and_vertices_graph_from_dot.impl}

\caption{Loading an undirected graph with named edges and vertices from a .dot
file\index{Load undirected named edges and vertices graph from dot}\label{alg:load_undirected_named_edges_and_vertices_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:load_directed_named_edges_and_vertices_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_named_edges_and_vertices_graph_from_dot_demo}
shows how to use the 'load\_undirected\_graph\_from\_dot' function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_named_edges_and_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_named\_edges\_and\_vertices\_graph\_from\_dot'
function\label{alg:load_undirected_named_edges_and_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how $K_{3}$ with named edges and vertices
is created using the 'create\_named\_edges\_and\_vertices\_k3\_graph'
function (algorithm \ref{alg:create_named_edges_and_vertices_k3_graph}),
saved and then loaded. The loaded graph is checked to be an undirected
graph similar to $K_{3}$ , with the same edge and vertex names (using
the 'get\_edge\_names' function, algorithm \ref{alg:get_edge_names},
and the 'get\_vertex\_names' function, algorithm \ref{alg:get_vertex_names}).


\section{Building graphs with bundled vertices\label{sec:Building-graphs-with-bundled-vertices}}

Up until now, the graphs created have had edges and vertices with
the built-in name property. In this chapter, graphs will be created,
in which the vertices can have a bundled 'my\_bundled\_vertex' type%
\footnote{I do not intend to be original in naming my data types%
}. The following graphs will be created:
\begin{itemize}
\item An empty directed graph that allows for bundled vertices: see chapter
\ref{alg:create_empty_directed_bundled_vertices_graph}
\item An empty undirected graph that allows for bundled vertices: see chapter
\ref{sub:create_empty_directed_bundled_vertices_graph}
\item A two-state Markov chain with bundled vertices: see chapter \ref{sub:create_bundled_vertices_markov_chain}
\item $K_{2}$with bundled vertices: see chapter \ref{sub:create_bundled_vertices_k2_graph}
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Create the vertex class, called 'my\_bundled\_vertex': see chapter
\ref{sub:my_bundled_vertex}
\item Adding a 'my\_bundled\_vertex': see chapter \ref{sub:add_bundled_vertex}
\item Getting the vertices 'my\_bundled\_vertex'-es: see chapter \ref{sub:get_bundled_vertex_my_vertexes}
\end{itemize}
These functions are mostly there for completion and showing which
data types are used.


\subsection{Creating the bundled vertex class\label{sub:my_bundled_vertex}}

Before creating an empty graph with bundled vertices, that bundled
vertex class must be created. In this tutorial, it is called 'my\_bundled\_vertex'.
'my\_bundled\_vertex' is a class that is nonsensical, but it can be
replaced by any other class type.

Here I will show the header file of 'my\_bundled\_vertex', as the
implementation of it is not important:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{my_bundled_vertex.impl}

\caption{Declaration of my\_bundled\_vertex\index{my_bundled_vertex@my\_bundled\_vertex}\index{my_bundled_vertex.h@my\_bundled\_vertex.h}\index{my_vertex declaration@my\_vertex declaration}\index{Declaration, my_bundled_vertex@Declaration, my\_bundled\_vertex}\label{alg:my_bundled_vertex_h}}
\end{algorithm}


'my\_bundled\_vertex' is a class that has multiple properties: 
\begin{itemize}
\item It has four public member variables: the double 'm\_x' ('m\_\index{m_@m\_}'
stands for member\index{member}), the double 'm\_y', the std::string
m\_name and the std::string m\_description. These variables must be
public
\item It has a default constructor
\item It is copyable
\item It is comparable for equality (it has operator==), which is needed
for searching
\end{itemize}
'my\_bundled\_vertex' does not have to have the stream operators defined
for file I/O, as this goes via the public member variables.


\subsection{Create the empty directed graph with bundled vertices\label{sub:create_empty_directed_bundled_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_bundled_vertices_graph.impl}

\caption{Creating an empty directed graph with bundled vertices\index{Create empty directed bundled vertices graph}\label{alg:create_empty_directed_bundled_vertices_graph}}
\end{algorithm}


This graph:
\begin{itemize}
\item has its out edges stored in a std::vector (due to the first boost::vecS\index{boost::vecS})
\item has its vertices stored in a std::vector (due to the second boost::vecS\index{boost::vecS})
\item is directed (due to the boost::directedS\index{boost::directedS})
\item The vertices have one property: they have a bundled type, that is
of data type 'my\_bundled\_vertex'
\item The edges and graph have no properties
\item Edges are stored in a std::list
\end{itemize}
The boost::adjacency\_list has a new, fourth template argument 'my\_bundled\_vertex\index{my_bundled_vertex@my\_bundled\_vertex}'.
This can be read as: ``vertices have the bundled property 'my\_bundled\_vertex'''.
Or simply: ``vertices have a bundled type called my\_bundled\_vertex''.


\subsection{Create the empty undirected graph with bundled vertices\label{sub:create_empty_undirected_bundled_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_bundled_vertices_graph.impl}

\caption{Creating an empty undirected graph with bundled vertices\index{Create empty undirected bundled vertices graph}\label{alg:create_empty_undirected_bundled_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_bundled_vertices_graph},
except that the directedness (the third template argument) is undirected
(due to the boost::undirectedS\index{boost::undirectedS}).


\subsection{Add a bundled vertex\label{sub:add_bundled_vertex}}

Adding a bundled vertex is very similar to adding a named vertex (chapter
\ref{sub:add_named_vertex}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_bundled_vertex.impl}

\caption{Add a bundled vertex\index{Add bundled vertex}\label{alg:add_bundled_vertex}}
\end{algorithm}


When having added a new (abstract) vertex to the graph, the vertex
descriptor is used to set the 'my\_bundled\_vertex' in the graph.


\subsection{Getting the bundled vertices' my\_vertexes%
\footnote{the name 'my\_vertexes' is chosen to indicate this function returns
a container of my\_vertex%
}\label{sub:get_bundled_vertex_my_vertexes}}

When the vertices of a graph have any bundled 'my\_bundled\_vertex',
one can extract these as such:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_bundled_vertexes.impl}

\caption{Get the bundled vertices' my\_vertexes\index{Get bundled vertex my_vertexes@Get bundled vertex my\_vertexes}\label{alg:get_my_bundled_vertexes}}
\end{algorithm}


The 'my\_bundled\_vertex' bundled in each vertex is obtained from
a vertex descriptor and then put into a std::vector.

The order of the 'my\_bundled\_vertex' objects may be different after
saving and loading.

When trying to get the vertices' my\_bundled\_vertex from a graph
without these, you will get the error 'formed reference to void' (see
chapter \ref{sub:formed_reference_to_void}).


\subsection{Creating a two-state Markov chain with bundled vertices\label{sub:create_bundled_vertices_markov_chain}}


\subsubsection{Graph}

Figure \ref{fig:bundled_vertices_markov_chain} shows the graph that
will be reproduced:

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]   
  \tikzstyle{every state}=[]
  \node[state] (A) 
    {Sunny, Yellow, 1.0, 2.0};   
  \node[state] (B) [right of=A] 
    {Not rainy, Not grey, 3.0, 4.0}
  ;   
  \path (A) edge [loop  left] node {} (A)
        (A) edge [bend  left] node {} (B)
        (B) edge [bend  left] node {} (A)
        (B) edge [loop right] node {} (B); 
\end{tikzpicture}

\caption{A two-state Markov chain where the vertices have bundled properies
and the edges have no properties. The vertices' properties are nonsensical\label{fig:bundled_vertices_markov_chain}}
\end{figure}



\subsubsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with bundled vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_bundled_vertices_markov_chain.impl}

\caption{Creating the two-state Markov chain as depicted in figure \ref{fig:bundled_vertices_markov_chain}\index{Create bundled vertices Markov chain}\label{alg:create_bundled_vertices_markov_chain}}
\end{algorithm}



\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_bundled_vertices_markov_chain_demo.impl}

\caption{Demo of the 'create\_bundled\_vertices\_markov\_chain' function (algorithm
\ref{alg:create_bundled_vertices_markov_chain})\label{alg:create_bundled_and_vertices_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_bundled_vertices_markov_chain.dot}

\caption{.dot file created from the 'create\_bundled\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_bundled_vertices_markov_chain}),
converted from graph to .dot file using algorithm \ref{alg:save_bundled_vertices_graph_to_dot}\label{alg:create_bundled_vertices_markov_chain.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_bundled_vertices_markov_chain}

\caption{.svg file created from the 'create\_bundled\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_bundled_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_bundled_vertices_markov_chain.svg}}
\end{figure}



\subsection{Creating $K_{2}$ with bundled vertices\label{sub:create_bundled_vertices_k2_graph}}


\subsubsection{Graph}

We reproduce the $K_{2}$ with named vertices of chapter \ref{sub:create_named_vertices_k2_graph}
, but with our bundled vertices intead, as show in figure \ref{fig:bundled_vertices_k2_graph}:

\begin{figure}[H]
\begin{tikzpicture}[>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]   
\tikzstyle{every state}=[]
\node[state] (A)              {Me,Myself,1.0,2.0};   
\node[state] (B) [right of=A] {My computer,Not me,3.0,4.0};   
\path (A) edge [] node {} (B); 
\end{tikzpicture}

\caption{$K_{2}$: a fully connected graph with two bundled vertices\label{fig:bundled_vertices_k2_graph}}
\end{figure}



\subsubsection{Function to create such a graph}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_bundled_vertices_k2_graph.impl}

\caption{Creating $K_{2}$ as depicted in figure \ref{fig:named_vertices_k2_graph}\index{Create bundled vertices K2 graph}\label{alg:create_bundled_vertices_k2_graph}}
\end{algorithm}


Most of the code is a slight modification of the 'create\_named\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_named_vertices_k2_graph}). In
the end, (references to) the my\_bundled\_vertices are obtained and
set with two bundled my\_bundled\_vertex objects.


\subsubsection{Creating such a graph}

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_bundled_vertices_k2_graph_demo.impl}

\caption{Demo of the 'create\_bundled\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_bundled_vertices_k2_graph})\label{alg:create_bundled_vertices_k2_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{reate_bundled_vertices_k2_graph.dot}

\caption{.dot file created from the 'create\_bundled\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_bundled_vertices_k2_graph}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_bundled_vertices_k2_graph.dot-1}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_bundled_vertices_k2_graph}

\caption{.svg file created from the 'create\_bundled\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_bundled_vertices_k2_graph}) its
.dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_bundled_vertices_k2_graph.svg}}
\end{figure}



\section{Working on graphs with bundled vertices\label{sec:Working-on-graphs-with-bundled-vertices}}

When using graphs with bundled vertices, their state gives a way to
find a vertex and working with it. This chapter shows some basic operations
on graphs with bundled vertices.
\begin{itemize}
\item Check if there exists a vertex with a certain 'my\_bundled\_vertex':
chapter \ref{sub:has_bundled_vertex_with_my_vertex}
\item Find a vertex with a certain 'my\_bundled\_vertex': chapter \ref{sub:find_bundled_vertex_with_my_vertex}
\item Get a vertex its 'my\_bundled\_vertex' from its vertex descriptor:
chapter \ref{sub:get_bundled_vertex_my_vertex}
\item Set a vertex its 'my\_bundled\_vertex' using its vertex descriptor:
chapter \ref{sub:set_bundled_vertex_my_vertex}
\item Setting all vertices their 'my\_bundled\_vertex'-es: chapter \ref{sub:set_bundled_vertex_my_vertexes}
\item Storing an directed/undirected graph with bundled vertices as a .dot
file: chapter \ref{sub:save_bundled_vertices_graph_to_dot}
\item Loading a directed graph with bundled vertices from a .dot file: chapter
\ref{sub:load_directed_bundled_vertices_graph_from_dot}
\item Loading an undirected directed graph with bundled vertices from a
.dot file: chapter \ref{sub:load_undirected_bundled_vertices_graph_from_dot}
\end{itemize}

\subsection{Has a bundled vertex with a my\_bundled\_vertex\label{sub:has_bundled_vertex_with_my_vertex}}

Before modifying our vertices, let's first determine if we can find
a vertex by its bundled type ('my\_bundled\_vertex') in a graph. After
obtain the vertex iterators, we can dereference each these to obtain
the vertex descriptors and then compare each vertex its 'my\_bundled\_vertex'
with the one desired.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_bundled_vertex_with_my_vertex.impl}

\caption{Find if there is vertex with a certain my\_bundled\_vertex\index{Has bundled vertex with my_vertex@Has bundled vertex with my\_vertex}\label{alg:has_bundled_vertex_with_my_vertex}}
\end{algorithm}


This function can be demonstrated as in algorithm \ref{alg:has_bundled_vertex_with_my_vertex_demo},
where a certain my\_bundled\_vertex cannot be found in an empty graph.
After adding the desired my\_bundled\_vertex, it is found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_bundled_vertex_with_my_vertex_demo.impl}

\caption{Demonstration of the 'has\_bundled\_vertex\_with\_my\_vertex' function\label{alg:has_bundled_vertex_with_my_vertex_demo}}
\end{algorithm}


Note that this function only finds if there is at least one bundled
vertex with that my\_bundled\_vertex: it does not tell how many bundled
vertices with that my\_bundled\_vertex exist in the graph.


\subsection{Find a bundled vertex with a certain my\_bundled\_vertex\label{sub:find_bundled_vertex_with_my_vertex}}

Where STL functions work with iterators, here we obtain a vertex descriptor
(see chapter \ref{sub:Vertex-descriptors}) to obtain a handle to
the desired vertex. Algorithm \ref{alg:find_first_bundled_vertex_with_my_vertex}
shows how to obtain a vertex descriptor to the first vertex found
with a specific 'my\_bundled\_vertex' value.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_bundled_vertex_with_my_vertex.impl}

\caption{Find the first vertex with a certain my\_bundled\_vertex\index{Find first bundled vertex with my_vertex@Find first bundled vertex with my\_vertex}\label{alg:find_first_bundled_vertex_with_my_vertex}}
\end{algorithm}


With the vertex descriptor obtained, one can read and modify the vertex
and the edges surrounding it. Algorithm \ref{alg:find_first_bundled_vertex_with_my_vertex_demo}
shows some examples of how to do so.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_bundled_vertex_with_my_vertex_demo.impl}

\caption{Demonstration of the 'find\_first\_bundled\_vertex\_with\_my\_vertex'
function\label{alg:find_first_bundled_vertex_with_my_vertex_demo}}
\end{algorithm}



\subsection{Get a bundled vertex its 'my\_bundled\_vertex'\label{sub:get_bundled_vertex_my_vertex}}

To obtain the 'my\_bundled\_vertex' from a vertex descriptor is simple:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_bundled_vertex.impl}

\caption{Get a bundled vertex its my\_vertex from its vertex descriptor\index{Get bundled vertex my_bundled_vertex@Get bundled vertex my\_bundled\_vertex}\label{alg:get_bundled_vertex_my_vertex}}
\end{algorithm}


One can just use the graph as a property map and let it be looked-up.

To use 'get\_bundled\_vertex\_my\_vertex', one first needs to obtain
a vertex descriptor. Algorithm \ref{alg:get_bundled_vertex_my_vertex_demo}
shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_bundled_vertex_demo.impl}

\caption{Demonstration if the 'get\_bundled\_vertex\_my\_vertex' function\label{alg:get_bundled_vertex_my_vertex_demo}}
\end{algorithm}



\subsection{Set a bundled vertex its my\_vertex\label{sub:set_bundled_vertex_my_vertex}}

If you know how to get the 'my\_bundled\_vertex' from a vertex descriptor,
setting it is just as easy, as shown in algorithm \ref{alg:set_bundled_vertex_my_vertex}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_bundled_vertex.impl}

\caption{Set a bundled vertex its my\_vertex from its vertex descriptor\index{Set vertex my_vertex@Set vertex my\_vertex}\label{alg:set_bundled_vertex_my_vertex}}
\end{algorithm}


To use 'set\_bundled\_vertex\_my\_vertex', one first needs to obtain
a vertex descriptor. Algorithm \ref{alg:set_bundled_vertex_my_vertex_demo}
shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_bundled_vertex_demo.impl}

\caption{Demonstration if the 'set\_bundled\_vertex\_my\_vertex' function\label{alg:set_bundled_vertex_my_vertex_demo}}
\end{algorithm}



\subsection{Setting all bundled vertices' my\_vertex objects\label{sub:set_bundled_vertex_my_vertexes}}

When the vertices of a graph are 'my\_bundled\_vertex' objects, one
can set these as such:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_bundled_vertexes.impl}

\caption{Setting the bundled vertices' 'my\_bundled\_vertex'-es\index{Set bundled vertex my_bundled_vertexes@Set bundled vertex my\_bundled\_vertexes}\label{alg:set_bundled_vertex_my_vertexes}}
\end{algorithm}



\subsection{Storing a graph with bundled vertices as a .dot\label{sub:save_bundled_vertices_graph_to_dot}}

If you used the 'create\_bundled\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_bundled_vertices_k2_graph}) to produce a $K_{2}$
graph with vertices associated with 'my\_bundled\_vertex' objects,
you can store these with algorithm \ref{alg:save_bundled_vertices_graph_to_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_bundled_vertices_graph_to_dot.impl}

\caption{Storing a graph with bundled vertices as a .dot file\index{Save bundled vertices graph to dot}\label{alg:save_bundled_vertices_graph_to_dot}}
\end{algorithm}


This code looks small, because we call the 'make\_bundled\_vertices\_writer'
function, which is shown in algorithm \ref{alg:make_bundled_vertices_writer}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{make_bundled_vertices_writer.impl}

\caption{The 'make\_bundled\_vertices\_writer' function\index{make_bundled_vertices_writer@make\_bundled\_vertices\_writer}\label{alg:make_bundled_vertices_writer}}
\end{algorithm}


Also this function is forwarding the real work to the 'bundled\_vertices\_writer',
shown in algorithm \ref{alg:bundled_vertices_writer}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{bundled_vertices_writer.impl}

\caption{The 'bundled\_vertices\_writer' function\index{bundled_vertices_writer@bundled\_vertices\_writer}\label{alg:bundled_vertices_writer}}
\end{algorithm}


Here, some interesting things are happening: the writer needs the
bundled property maps to work with and thus copies the whole graph
to its internals. I have chosen to map the 'my\_bundled\_vertex' member
variables to Graphviz attributes (see chapter \ref{sub:Graphviz-attributes}
for most Graphviz attributes) as shown in table \ref{tab:Mapping-of-my_bundled_vertex-to-Graphviz-attributes}:

\begin{table}[H]
\begin{tabular}{|c|c|c|c|}
\hline 
my\_bundled\_vertex variable & C++ data type & Graphviz data type & Graphviz attribute\tabularnewline
\hline 
\hline 
m\_name & std::string & string & label\tabularnewline
\hline 
m\_description & std::string & string & comment\tabularnewline
\hline 
m\_x & double & double & width\tabularnewline
\hline 
m\_y & double & double & height\tabularnewline
\hline 
\end{tabular}

\caption{Mapping of my\_bundled\_vertex member variable and Graphviz attributes\label{tab:Mapping-of-my_bundled_vertex-to-Graphviz-attributes}}
\end{table}


Important in this mapping is that the C++ and the Graphviz data types
match. I also chose attributes that matched as closely as possible.

The writer also encodes the std::string of the name and description
to a Graphviz-friendly format. When loading the .dot file again, this
will have to be undone again.


\subsection{Loading a directed graph with bundled vertices from a .dot\label{sub:load_directed_bundled_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph with bundled vertices is loaded,
as shown in algorithm \ref{alg:load_directed_bundled_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_bundled_vertices_graph_from_dot.impl}

\caption{Loading a directed graph with bundled vertices from a .dot file\index{Load directed bundled vertices graph from dot}\label{alg:load_directed_bundled_vertices_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists.
Then an empty directed graph is created, to save typing the typename
explicitly.

Then a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with its default constructor, after which we set it to
follow the same mapping as in the previous chapter. From this and
the empty graph, 'boost::read\_graphviz'\index{boost::read_graphviz@boost::read\_graphviz}
is called to build up the graph.

At the moment the graph is created, all 'my\_bundled\_vertex' their
names and description are in a Graphviz-friendly format. By obtaining
all vertex iterators and vertex descriptors, the encoding is made
undone.

Algorithm \ref{alg:load_directed_bundled_vertices_graph_from_dot_demo}
shows how to use the 'load\_directed\_bundled\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_bundled_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_bundled\_vertices\_graph\_from\_dot'
function\label{alg:load_directed_bundled_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_bundled\_vertices\_markov\_chain' function (algorithm \ref{alg:create_bundled_vertices_markov_chain}),
saved and then loaded. The loaded graph is checked to be the same
as the original.


\subsection{Loading an undirected graph with bundled vertices from a .dot\label{sub:load_undirected_bundled_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an undirected graph with bundled vertices is loaded,
as shown in algorithm \ref{alg:load_undirected_bundled_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_bundled_vertices_graph_from_dot.impl}

\caption{Loading an undirected graph with bundled vertices from a .dot file\index{Load undirected bundled vertices graph from dot}\label{alg:load_undirected_bundled_vertices_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:load_directed_bundled_vertices_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_bundled_vertices_graph_from_dot_demo}
shows how to use the 'load\_undirected\_bundled\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_bundled_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_bundled\_vertices\_graph\_from\_dot'
function\label{alg:load_undirected_bundled_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how $K_{2}$ with bundled vertices is created
using the 'create\_bundled\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_bundled_vertices_k2_graph}), saved and then loaded.
The loaded graph is checked to be the same as the original.


\section{Building graphs with bundled edges and vertices}

Up until now, the graphs created have had only bundled vertices. In
this chapter, graphs will be created, in which both the edges and
vertices have a bundled 'my\_bundled\_edge' and 'my\_bundled\_edge'
type%
\footnote{I do not intend to be original in naming my data types%
}.
\begin{itemize}
\item An empty directed graph that allows for bundled edges and vertices:
see chapter \ref{sub:create_empty_directed_bundled_edges_and_vertices_graph}
\item An empty undirected graph that allows for bundled edges and vertices:
see chapter \ref{sub:create_empty_undirected_bundled_edges_and_vertices_graph}
\item A two-state Markov chain with bundled edges and vertices: see chapter
\ref{sub:create_bundled_edges_and_vertices_markov_chain}
\item $K_{3}$with bundled edges and vertices: see chapter \ref{sub:create_bundled_edges_and_vertices_k3}
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Creating the 'my\_bundled\_edge' class: see chapter \ref{sub:my_bundled_edge}
\item Adding a bundled 'my\_bundled\_edge': see chapter \ref{sub:add_bundled_edge}
\end{itemize}
These functions are mostly there for completion and showing which
data types are used.


\subsection{Creating the bundled edge class\label{sub:my_bundled_edge}}

In this example, I create a 'my\_bundled\_edge' class. Here I will
show the header file of it, as the implementation of it is not important
yet.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{my_bundled_edge.impl}

\caption{Declaration of my\_bundled\_edge\index{my_bundled_edge@my\_bundled\_edge}\index{my_bundled_edge.h@my\_bundled\_edge.h}\index{my_bundled_edge declaration@my\_bundled\_edge declaration}\index{Declaration, my_bundled_edge@Declaration, my\_bundled\_edge}\label{alg:my_bundled_edge_h}}
\end{algorithm}


my\_bundled\_edge is a class that has multiple properties: two doubles
'm\_width' ('m\_\index{m_@m\_}' stands for member\index{member})
and 'm\_height', and two std::strings m\_name and m\_description.
'my\_bundled\_edge' is copyable, but cannot trivially be converted
to a std::string.' 'my\_bundled\_edge' is comparable for equality
(that is, operator== is defined).

'my\_bundled\_edge' does not have to have the stream operators defined
for file I/O, as this goes via the public member variables.


\subsection{Create an empty directed graph with bundled edges and vertices\label{sub:create_empty_directed_bundled_edges_and_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_bundled_edges_and_vertices_graph.impl}

\caption{Creating an empty directed graph with bundled edges and vertices\index{Create empty directed bundled edges and vertices graph}\label{alg:create_empty_directed_bundled_edges_and_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_custom_vertices_graph},
except that there is a new, fifth template argument:

\begin{lstlisting}
boost::property<boost::edge_bundled_type_t, my_edge>
\end{lstlisting}
\index{boost::property}\index{boost::edge_bundled_type_t@boost::edge\_bundled\_type\_t}\index{my_edge@my\_edge}This
can be read as: ``edges have the property 'boost::edge\_bundled\_type\_t',
which is of data type 'my\_bundled\_edge'''. Or simply: ``edges
have a bundled type called my\_bundled\_edge''.

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_bundled_edges_and_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_directed\_bundled\_edges\_and\_vertices\_graph'
function\label{alg:create_empty_directed_bundled_edges_and_vertices_graph_demo}}
\end{algorithm}



\subsection{Create an empty undirected graph with bundled edges and vertices\label{sub:create_empty_undirected_bundled_edges_and_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_bundled_edges_and_vertices_graph.impl}

\caption{Creating an empty undirected graph with bundled edges and vertices\index{Create empty undirected bundled edges and vertices graph}\label{alg:create_empty_undirected_bundled_edges_and_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_bundled_edges_and_vertices_graph},
except that the directedness (the third template argument) is undirected
(due to the boost::undirectedS\index{boost::undirectedS}).

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_bundled_edges_and_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_undirected\_bundled\_edges\_and\_vertices\_graph'
function\label{alg:create_empty_undirected_bundled_edges_and_vertices_graph_demo}}
\end{algorithm}



\subsection{Add a bundled edge\label{sub:add_bundled_edge}}

Adding a bundled edge is very similar to adding a named edge (chapter
\ref{sub:add_named_edge}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_bundled_edge.impl}

\caption{Add a bundled edge\index{Add bundled edge}\label{alg:add_bundled_edge}}
\end{algorithm}


When having added a new (abstract) edge to the graph, the edge descriptor
is used to set the my\_edge in the graph.

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_bundled_edge_demo.impl}

\caption{Demo of 'add\_bundled\_edge'\label{alg:add_bundled_edge_demo}}
\end{algorithm}



\subsection{Getting the bundled edges my\_edges\label{sub:get_bundled_edge_my_edges}}

When the edges of a graph are 'my\_bundled\_edge' objects, one can
extract these all as such:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_bundled_edges.impl}

\caption{Get the edges' my\_bundled\_edges\index{Get edge my_bundled_edges@Get edge my\_bundled\_edges}\label{alg:get_bundled_edge_my_edges}}
\end{algorithm}


The 'my\_bundled\_edge' object associated with the edges are obtained
from the graph its property\_map and then put into a std::vector.

Note: the order of the my\_bundled\_edge objects may be different
after saving and loading.

When trying to get the edges' my\_bundled\_edge objects from a graph
without bundled edges objects associated, you will get the error 'formed
reference to void' (see chapter \ref{sub:formed_reference_to_void}).


\subsection{Creating a Markov-chain with bundled edges and vertices\label{sub:create_bundled_edges_and_vertices_markov_chain}}


\subsubsection{Graph}

Figure \ref{fig:bundled_edges_and_vertices_markov_chain} shows the
graph that will be reproduced:

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=9cm, semithick]   
  \tikzstyle{every state}=[]
  \node[state] (A) 
    {Stable,Right, 1.0, 2.0};   
  \node[state] (B) [right of=A] 
    {Not unstable,Not left, 3.0, 4.0}
  ;   
  \path (A) edge [loop above] node {Red,Heat,1,2} (A)
        (A) edge [bend  left] node {Orange,Lose heat,3,4} (B)
        (B) edge [bend  left] node {Yellow cold,Heat,4,5} (A)
        (B) edge [loop above] node {Green cols,Stay cool,6,7} (B); 
\end{tikzpicture}

\caption{A two-state Markov chain where the edges and vertices have bundled
properies. The edges' and vertices' properties are nonsensical\label{fig:bundled_edges_and_vertices_markov_chain}}
\end{figure}



\subsubsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with bundled edges
and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_bundled_edges_and_vertices_markov_chain.impl}

\caption{Creating the two-state Markov chain as depicted in figure \ref{fig:bundled_edges_and_vertices_markov_chain}\index{Create bundled edges and vertices Markov chain}\label{alg:create_bundled_edges_and_vertices_markov_chain}}
\end{algorithm}



\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_bundled_edges_and_vertices_markov_chain_demo.impl}

\caption{Demo of the 'create\_bundled\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_bundled_edges_and_vertices_markov_chain})\label{alg:create_bundled_edges_and_vertices_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_bundled_edges_and_vertices_markov_chain.dot}

\caption{.dot file created from the 'create\_bundled\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_bundled_edges_and_vertices_markov_chain}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_bundled_edges_and_vertices_markov_chain.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_bundled_edges_and_vertices_markov_chain}

\caption{.svg file created from the 'create\_bundled\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_bundled_edges_and_vertices_markov_chain.svg}}
\end{figure}



\subsection{Creating $K_{3}$ with bundled edges and vertices\label{sub:create_bundled_edges_and_vertices_k3}}

Instead of using edges with a name, or other properties, here we use
a bundled edge class called 'my\_bundled\_edge'.


\subsubsection{Graph}

We reproduce the $K_{3}$ with named edges and vertices of chapter
\ref{sub:create_named_edges_and_vertices_k3} , but with our bundled
edges and vertices intead:

\begin{figure}[H]
\tikz 
\draw[] 
  (2,4) node[draw=black,fill=white,shape=circle,text=black] {Red,Not green,1,2} 
   -- (5,2) node[anchor=west] {Oxygen,Air,1,2} 
   -- (8,0) node[draw=black,fill=white,shape=circle,text=black] {Light red,Not dark,3,4} 
   -- (4,0) node[anchor=north] {Helium,From tube,3,4} 
   -- (0,0) node[draw=black,fill=white,shape=circle,text=black] {Orange,Orangy,5,6} 
   -- (1,2) node[anchor=east] {Stable temperature,Here,5,6} 
   -- (2,4)
;

\caption{$K_{3}$: a fully connected graph with three named edges and vertices
\label{fig:create_bundled_edges_and_vertices_k3}}
\end{figure}



\subsubsection{Function to create such a graph}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_bundled_edges_and_vertices_k3_graph.impl}

\caption{Creating $K_{3}$ as depicted in figure \ref{fig:named_edges_and_vertices_k3}\index{Create bundled edges and vertices K3 graph}\label{alg:create_bundled_edges_and_vertices_k3_graph}}
\end{algorithm}


Most of the code is a slight modification of algorithm \ref{alg:create_named_edges_and_vertices_k3_graph}.
In the end, the my\_edges and my\_vertices are obtained as the graph
its property\_map and set with the 'my\_bundled\_edge' and 'my\_bundled\_vertex'
objects.


\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_bundled_edges_and_vertices_k3_graph_demo.impl}

\caption{Demo of the 'create\_bundled\_edges\_and\_vertices\_k3\_graph' function
(algorithm \ref{alg:create_bundled_edges_and_vertices_k3_graph})\label{alg:create_bundled_edges_and_vertices_k3_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_bundled_edges_and_vertices_k3_graph.dot}

\caption{.dot file created from the 'create\_bundled\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_bundled_edges_and_vertices_k3_graph}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_bundled_edges_and_vertices_k3_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics[scale=0.5]{create_bundled_edges_and_vertices_k3_graph}

\caption{.svg file created from the 'create\_bundled\_edges\_and\_vertices\_k3\_graph'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_bundled_edges_and_vertices_k3_graph.svg}}
\end{figure}



\section{Working on graphs with bundled edges and vertices}


\subsection{Has a my\_bundled\_edge\label{sub:has_bundled_edge_with_my_edge}}

Before modifying our edges, let's first determine if we can find an
edge by its bundled type ('my\_bundled\_edge') in a graph. After obtaing
a my\_bundled\_edge map, we obtain the edge iterators, dereference
these to obtain the edge descriptors and then compare each edge its
my\_bundled\_edge with the one desired.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_bundled_edge_with_my_edge.impl}

\caption{Find if there is a bundled edge with a certain my\_bundled\_edge\index{Has bundled edge with my_bundled_edge@Has bundled edge with my\_bundled\_edge}\label{alg:has_bundled_edge_with_my_edge}}
\end{algorithm}


This function can be demonstrated as in algorithm \ref{alg:has_bundled_edge_with_my_edge_demo},
where a certain 'my\_bundled\_edge' cannot be found in an empty graph.
After adding the desired my\_bundled\_edge, it is found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_bundled_edge_with_my_edge_demo.impl}

\caption{Demonstration of the 'has\_bundled\_edge\_with\_my\_edge' function\label{alg:has_bundled_edge_with_my_edge_demo}}
\end{algorithm}


Note that this function only finds if there is at least one edge with
that my\_bundled\_edge: it does not tell how many edges with that
my\_bundled\_edge exist in the graph.


\subsection{Find a my\_bundled\_edge\label{sub:find_first_bundled_edge_with_my_edge}}

Where STL functions work with iterators, here we obtain an edge descriptor
(see chapter \ref{sub:Edge-descriptors}) to obtain a handle to the
desired edge. Algorithm \ref{alg:find_first_bundled_edge_with_my_edge}
shows how to obtain an edge descriptor to the first edge found with
a specific my\_bundled\_edge value.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_bundled_edge_with_my_edge.impl}

\caption{Find the first bundled edge with a certain my\_bundled\_edge\index{Find first bundled edge with my_bundled_edge@Find first bundled edge with my\_bundled\_edge}\label{alg:find_first_bundled_edge_with_my_edge}}
\end{algorithm}


With the edge descriptor obtained, one can read and modify the edge
and the vertices surrounding it. Algorithm \ref{alg:find_first_bundled_edge_with_my_edge_demo}
shows some examples of how to do so.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_bundled_edge_with_my_edge_demo.impl}

\caption{Demonstration of the 'find\_first\_bundled\_edge\_with\_my\_edge'
function\label{alg:find_first_bundled_edge_with_my_edge_demo}}
\end{algorithm}



\subsection{Get an edge its my\_bundled\_edge\label{sub:get_bundled_edge_my_edge}}

To obtain the my\_bundled\_edge from an edge descriptor, one needs
to pull out the my\_bundled\_edges map and then look up the my\_edge
of interest.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_bundled_edge.impl}

\caption{Get a vertex its my\_bundled\_vertex from its vertex descriptor\index{Get my_bundled_edge@Get my\_bundled\_edge}\label{alg:get_bundled_edge_my_edge}}
\end{algorithm}


To use 'get\_my\_bundled\_edge', one first needs to obtain an edge
descriptor. Algorithm \ref{alg:get_bundled_edge_my_edge_demo} shows
a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_bundled_edge_demo.impl}

\caption{Demonstration if the 'get\_my\_bundled\_edge' function\label{alg:get_bundled_edge_my_edge_demo}}
\end{algorithm}



\subsection{Set an edge its my\_bundled\_edge\label{sub:set_bundled_edge_my_edge}}

If you know how to get the my\_bundled\_edge from an edge descriptor,
setting it is just as easy, as shown in algorithm \ref{alg:set_bundled_edge_my_edge}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_bundled_edge.impl}

\caption{Set a bundled edge its my\_bundled\_edge from its edge descriptor\index{Set bundled edge my_bundled_edge@Set bundled edge my\_bundled\_edge}\label{alg:set_bundled_edge_my_edge}}
\end{algorithm}


To use 'set\_bundled\_edge\_my\_edge', one first needs to obtain an
edge descriptor. Algorithm \ref{alg:set_bundled_edge_my_edge_demo}
shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_bundled_edge_demo.impl}

\caption{Demonstration if the 'set\_bundled\_edge\_my\_edge' function\label{alg:set_bundled_edge_my_edge_demo}}
\end{algorithm}



\subsection{Storing a graph with bundled edges and vertices as a .dot\label{sub:save_bundled_edges_and_vertices_graph_to_dot}\index{Save graph with bundled edges and vertices as .dot}\index{Create .dot from graph with bundled edges and vertices} }

If you used the 'create\_bundled\_edges\_and\_vertices\_k3\_graph'
function (algorithm \ref{alg:create_bundled_edges_and_vertices_k3_graph})
to produce a $K_{3}$ graph with edges and vertices associated with
my\_bundled\_edge and my\_bundled\_vertex objects, you can store these
my\_bundled\_edges and my\_bundled\_vertex-es additionally with algorithm
\ref{alg:save_bundled_edges_and_vertices_graph_to_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_bundled_edges_and_vertices_graph_to_dot.impl}

\caption{Storing a graph with bundled edges and vertices as a .dot file\index{Save bundled edges and vertices graph to dot}\label{alg:save_bundled_edges_and_vertices_graph_to_dot}}
\end{algorithm}



\subsection{Load a directed graph with bundled edges and vertices from a .dot
file\label{sub:sub:load_directed_bundled_edges_and_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph with bundled edges and vertices
is loaded, as shown in algorithm \ref{alg:load_directed_bundled_edges_and_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_bundled_edges_and_vertices_graph_from_dot.impl}

\caption{Loading a directed graph with bundled edges and vertices from a .dot
file\index{Load directed bundled edges and vertices graph from dot}\label{alg:load_directed_bundled_edges_and_vertices_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists.
Then an empty directed graph is created. Next to this, a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with its default constructor, after which we direct the
boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
to find a 'node\_id' and 'label' in the vertex name map, 'edge\_id'
and 'label to the edge name map. From this and the empty graph, 'boost::read\_graphviz'\index{boost::read_graphviz@boost::read\_graphviz}
is called to build up the graph.

Algorithm \ref{alg:load_directed_bundled_edges_and_vertices_graph_from_dot_demo}
shows how to use the 'load\_directed\_bundled\_edges\_and\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_bundled_edges_and_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_bundled\_edges\_and\_vertices\_graph\_from\_dot'
function\label{alg:load_directed_bundled_edges_and_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_bundled\_edges\_and\_vertices\_markov\_chain' function (algorithm
\ref{alg:create_bundled_edges_and_vertices_markov_chain}), saved
and then loaded.


\subsection{Load an undirected graph with bundled edges and vertices from a .dot
file\label{sub:load_undirected_bundled_edges_and_vertices_graph_from_dot}\index{Load undirected graph with bundled edges and vertices from .dot}\index{Create undirected graph with bundled edges and vertices from .dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an undirected graph with bundled edges and vertices
is loaded, as shown in algorithm \ref{alg:load_undirected_bundled_edges_and_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_bundled_edges_and_vertices_graph_from_dot.impl}

\caption{Loading an undirected graph with bundled edges and vertices from a
.dot file\index{Load undirected bundled edges and vertices graph from dot}\label{alg:load_undirected_bundled_edges_and_vertices_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:sub:load_directed_bundled_edges_and_vertices_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_bundled_edges_and_vertices_graph_from_dot_demo}
shows how to use the 'load\_undirected\_bundled\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_bundled_edges_and_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_bundled\_edges\_and\_vertices\_graph\_from\_dot'
function\label{alg:load_undirected_bundled_edges_and_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how $K_{2}$ with bundled vertices is created
using the 'create\_bundled\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_custom_vertices_k2_graph}), saved and then loaded.
The loaded graph is checked to be a graph similar to the original.


\section{Building graphs with custom vertices\label{sec:Building-graphs-with-custom-properties}}

Instead of using bundled properties, you can also add a new custom
property. The difference is that instead of having a class \emph{as}
a vertex, vertices have \emph{an additional property} where the 'my\_custom\_vertex'
is stored, next to properties like vertex name, edge delay (see chapter
\ref{sub:all_properties} for all properties). The following graphs
will be created:
\begin{itemize}
\item An empty directed graph that allows for custom vertices: see chapter
\ref{alg:create_empty_directed_custom_vertices_graph}
\item An empty undirected graph that allows for custom vertices: see chapter
\ref{sub:create_empty_directed_custom_vertices_graph}
\item A two-state Markov chain with custom vertices: see chapter \ref{sub:create_custom_vertices_markov_chain}
\item $K_{2}$with custom vertices: see chapter \ref{sub:create_custom_vertices_k2_graph}
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Installing a new vertex property, called 'vertex\_custom\_type\index{vertex_custom_type@vertex\_custom\_type}':
chapter \ref{sub:install_vertex_custom_type}
\item Adding a custom vertex: see chapter \ref{sub:add_custom_vertex}
\item Getting the custom vertices my\_vertex-es: see chapter \ref{sub:get_vertex_my_vertexes}
\end{itemize}
These functions are mostly there for completion and showing which
data types are used.


\subsection{Creating the vertex class\label{sub:my_custom_vertex}}

Before creating an empty graph with custom vertices, that custom vertex
class must be created. In this tutorial, it is called 'my\_custom\_vertex'.
'my\_custom\_vertex' is a class that is nonsensical, but it can be
replaced by any other class type.

Here I will show the header file of 'my\_custom\_vertex', as the implementation
of it is not important:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{my_custom_vertex.impl}

\caption{Declaration of my\_custom\_vertex\index{my_custom_vertex@my\_custom\_vertex}\index{my_custom_vertex.h@my\_custom\_vertex.h}\index{my_custom_vertex declaration@my\_custom\_vertex declaration}\index{Declaration, my_custom_vertex@Declaration, my\_custom\_vertex}\label{alg:my_custom_vertex_h}}
\end{algorithm}


'my\_custom\_vertex' is a class that has multiple properties: 
\begin{itemize}
\item It has four private member variables: the double 'm\_x' ('m\_\index{m_@m\_}'
stands for member\index{member}), the double 'm\_y', the std::string
m\_name and the std::string m\_description. These variables are private,
but there are getters supplied
\item It has a default constructor
\item It is copyable
\item It is comparable for equality (it has operator==), which is needed
for searching
\item It can be streamed (it has both operator<\textcompwordmark{}< and
operator>\textcompwordmark{}>), which is needed for file I/O. 
\end{itemize}
Special characters like comma's, quotes and whitespace cannot be streamed
without problems. The function 'graphviz\_encode' (algorithm \ref{alg:graphviz_encode})
can convert the elements to be streamed to a Graphviz-friendly version,
which can be decoded by 'graphviz\_decode' (algorithm \ref{alg:graphviz_decode}).


\subsection{Installing the new vertex property\label{sub:install_vertex_custom_type}}

Before creating an empty graph with custom vertices, this type must
be installed as a vertex property. Installing a new property would
have been easier, if 'more C++ compilers were standards conformant'
(\cite{siek2001boost} chapter 3.6). Boost.Graph uses the BOOST\_INSTALL\_PROPERTY\index{BOOST_INSTALL_PROPERTY@BOOST\_INSTALL\_PROPERTY}
macro\index{macro} to allow using a custom property:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{install_vertex_custom_type.impl}

\caption{Installing the vertex\_custom\_type property\index{Install vertex custom type}\label{alg:install_vertex_custom_type}}
\end{algorithm}


The enum value 314 must be unique.


\subsection{Create the empty directed graph with custom vertices\label{sub:create_empty_directed_custom_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_custom_vertices_graph.impl}

\caption{Creating an empty directed graph with custom vertices\index{Create empty directed custom vertices graph}\label{alg:create_empty_directed_custom_vertices_graph}}
\end{algorithm}


This graph:
\begin{itemize}
\item has its out edges stored in a std::vector (due to the first boost::vecS\index{boost::vecS})
\item has its vertices stored in a std::vector (due to the second boost::vecS\index{boost::vecS})
\item is directed (due to the boost::directedS\index{boost::directedS})
\item The vertices have one property: they have a custom type, that is of
data type my\_vertex (due to the boost::property< boost::vertex\_custom\_type\_t,my\_vertex>\index{boost::property}\index{boost::vertex_custom_type_t@boost::vertex\_custom\_type\_t}\index{my_vertex@my\_vertex}')
\item The edges and graph have no properties
\item Edges are stored in a std::list
\end{itemize}
The boost::adjacency\_list\index{boost::adjacency_list@boost::adjacency\_list}
has a new, fourth template argument 'boost::property< boost::vertex\_custom\_type\_t,my\_vertex>\index{boost::property}\index{boost::vertex_custom_type_t@boost::vertex\_custom\_type\_t}\index{my_vertex@my\_vertex}'.
This can be read as: ``vertices have the property 'boost::vertex\_custom\_type\_t',
which is of data type 'my\_vertex'''. Or simply: ``vertices have
a custom type called my\_vertex''.

The demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_custom_vertices_graph_demo.impl}

\caption{Demo how to create an empty directed graph with custom vertices\label{alg:create_empty_directed_custom_vertices_graph_demo}}
\end{algorithm}



\subsection{Create the empty undirected graph with custom vertices\label{sub:create_empty_undirected_custom_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_custom_vertices_graph.impl}

\caption{Creating an empty undirected graph with custom vertices\index{Create empty undirected custom vertices graph}\label{alg:create_empty_undirected_custom_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_custom_vertices_graph},
except that the directedness (the third template argument) is undirected
(due to the boost::undirectedS\index{boost::undirectedS}).

The demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_custom_vertices_graph_demo.impl}

\caption{Demo how to create an empty undirected graph with custom vertices\label{alg:create_empty_undirected_custom_vertices_graph_demo}}
\end{algorithm}



\subsection{Add a custom vertex\label{sub:add_custom_vertex}}

Adding a custom vertex is very similar to adding a named vertex (chapter
\ref{sub:add_named_vertex}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_custom_vertex.impl}

\caption{Add a custom vertex\index{Add custom vertex}\label{alg:add_custom_vertex}}
\end{algorithm}


When having added a new (abstract) vertex to the graph, the vertex
descriptor is used to set the my\_vertex in the graph its my\_vertex
map (using 'get(boost::vertex\_custom\_type,g)\index{boost::vertex_custom_type@boost::vertex\_custom\_type}\index{get}').

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_custom_vertex_demo.impl}

\caption{Demo of 'add\_custom\_vertex'\label{alg:add_custom_vertex_demo}}
\end{algorithm}



\subsection{Getting the vertices' my\_vertexes%
\footnote{the name 'my\_vertexes' is chosen to indicate this function returns
a container of my\_vertex%
}\label{sub:get_vertex_my_vertexes}}

When the vertices of a graph have any associated my\_vertex, one can
extract these as such:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_custom_vertexes.impl}

\caption{Get the my\_custom\_vertex objects\index{Get my_custom_vertexes@Get my\_custom\_vertexes}\label{alg:get_my_custom_vertexes}}
\end{algorithm}


The my\_vertex object associated with the vertices are obtained from
a boost::property\_map and then put into a std::vector.

The order of the 'my\_custom\_vertex' objects may be different after
saving and loading.

When trying to get the vertices' my\_vertex from a graph without my\_vertex
objects associated, you will get the error 'formed reference to void'
(see chapter \ref{sub:formed_reference_to_void}).

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_custom_vertexes_demo.impl}

\caption{Demo how to the vertices' my\_custom\_vertex objects\index{Get custom vertex my_custom_vertex objects@Get custom vertex my\_custom\_vertex objects}\label{alg:get_my_custom_vertexes_demo}}
\end{algorithm}



\subsection{Creating a two-state Markov chain with custom vertices\label{sub:create_custom_vertices_markov_chain}}


\subsubsection{Graph}

Figure \ref{fig:custom_vertices_markov_chain} shows the graph that
will be reproduced:

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=4cm, semithick]   
  \tikzstyle{every state}=[]
  \node[state] (A) 
    {Sunny, You [...], 1.0, 2.0};   
  \node[state] (B) [right of=A] 
    {Rainy, Many [...], 3.0, 4.0}
  ;   
  \path (A) edge [loop  left] node {} (A)
        (A) edge [bend  left] node {} (B)
        (B) edge [bend  left] node {} (A)
        (B) edge [loop right] node {} (B); 
\end{tikzpicture}

\caption{A two-state Markov chain where the vertices have custom properies
and the edges have no properties. The vertices' properties are nonsensical\label{fig:custom_vertices_markov_chain}}
\end{figure}



\subsubsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with custom vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_vertices_markov_chain.impl}

\caption{Creating the two-state Markov chain as depicted in figure \ref{fig:custom_vertices_markov_chain}\index{Create custom vertices Markov chain}\label{alg:create_custom_vertices_markov_chain}}
\end{algorithm}



\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_vertices_markov_chain_demo.impl}

\caption{Demo of the 'create\_custom\_vertices\_markov\_chain' function (algorithm
\ref{alg:create_custom_vertices_markov_chain})\label{alg:create_custom_and_vertices_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_custom_vertices_markov_chain.dot}

\caption{.dot file created from the 'create\_custom\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_vertices_markov_chain}),
converted from graph to .dot file using algorithm \ref{alg:save_custom_vertices_graph_to_dot}\label{alg:create_custom_vertices_markov_chain.dot}}
\end{algorithm}


This .dot file may look unexpectedly different: instead of a space,
there is this '{[}{[}:SPACE:{]}{]}'\index{{[}{[}:SPACE:{]}{]}} thing.
This is because the function 'graphviz\_encode' (algorithm \ref{alg:graphviz_encode})
made this conversion. In this example, I could have simply surrounded
the content by quotes, and this would have worked. I chose to use
'graphviz\_encode' because it works in all contexts.


\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_custom_vertices_markov_chain}

\caption{.svg file created from the 'create\_custom\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_vertices_markov_chain.svg}}
\end{figure}


This .svg file may look unexpectedly different: instead of a space,
there is this '{[}{[}:SPACE:{]}{]}'\index{{[}{[}:SPACE:{]}{]}} thing.
This is because the function 'graphviz\_encode' (algorithm \ref{alg:graphviz_encode})
made this conversion.


\subsection{Creating $K_{2}$ with custom vertices\label{sub:create_custom_vertices_k2_graph}}


\subsubsection{Graph}

We reproduce the $K_{2}$ with named vertices of chapter \ref{sub:create_named_vertices_k2_graph}
, but with our custom vertices intead.


\subsubsection{Function to create such a graph}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_vertices_k2_graph.impl}

\caption{Creating $K_{2}$ as depicted in figure \ref{fig:named_vertices_k2_graph}\index{Create custom vertices K2 graph}\label{alg:create_custom_vertices_k2_graph}}
\end{algorithm}


Most of the code is a slight modification of the 'create\_named\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_named_vertices_k2_graph}). In
the end, the my\_vertices are obtained as a boost::property\_map and
set with two custom my\_vertex objects.


\subsubsection{Creating such a graph}

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_vertices_k2_graph_demo.impl}

\caption{Demo of the 'create\_custom\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_custom_vertices_k2_graph})\label{alg:create_custom_and_vertices_k2_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_custom_vertices_k2_graph.dot}

\caption{.dot file created from the 'create\_custom\_vertices\_k2\_graph' function
(algorithm \ref{alg:create_custom_vertices_k2_graph}), converted
from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_custom_vertices_k2_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_custom_vertices_k2_graph}

\caption{.svg file created from the 'create\_custom\_vertices\_k2\_graph' function
(algorithm \ref{alg:create_custom_vertices_k2_graph}) its .dot file,
converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_vertices_k2_graph.svg}}
\end{figure}



\subsection{\textifsymbol[ifgeo]{100} Creating a path graph with custom vertices\label{sub:create_custom_vertices_path_graph}\index{Create path graph with custom vertices}\index{Path graph with custom vertices, create}}

Here we create a path graph with custom vertices


\subsubsection{Graph}

Here I show a path graph with four vertices (see figure \ref{fig:create_custom_vertices_path_graph}):

\begin{figure}[H]
\begin{tikzpicture}   
\tikzset{ 
  VertexStyle/.append style = {draw=black,fill=white,shape=circle,text=black}
}
\SetGraphUnit{4}
\Vertex{A}   
\EA(A){B}   
\EA(B){C}   
\EA(C){D}   
\Edge[](A)(B)   
\Edge[](B)(C)   
\Edge[](C)(D)   
\end{tikzpicture}

\caption{A path graph with four vertices \label{fig:create_custom_vertices_path_graph}}
\end{figure}



\subsubsection{Function to create such a graph}

To create a path graph, the following code can be used:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_vertices_path_graph.impl}

\caption{Creating a path graph as depicted in figure \ref{fig:create_custom_vertices_path_graph}\index{Create custom vertices path graph}\label{alg:create_custom_vertices_path_graph}}
\end{algorithm}



\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_custom_vertices_path_graph_demo} demonstrates
how to create a path graph with named vertices and checks if it has
the correct amount of edges and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_vertices_path_graph_demo.impl}

\caption{Demonstration of 'create\_named\_vertices\_path\_graph' \label{alg:create_custom_vertices_path_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced\label{sub:create_custom_vertices_path_graph.dot}}

This graph can be converted to the .dot file as shown in algorithm
\ref{alg:create_custom_vertices_path_graph.dot}:

\begin{algorithm}[H]
\verbatiminput{create_custom_vertices_path_graph.dot}

\caption{.dot file created from the 'create\_named\_vertices\_path\_graph'
function (algorithm \ref{alg:create_custom_vertices_path_graph}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_custom_vertices_path_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced\label{sub:create_custom_vertices_path_graph.svg}}

The .dot file can be converted to the .svg as shown in figure \ref{fig:create_custom_vertices_path_graph.svg}:

\begin{figure}[H]
\includegraphics{create_custom_vertices_path_graph_4}

\caption{.svg file created from the 'create\_named\_vertices\_path\_graph'
function (algorithm \ref{alg:create_custom_vertices_path_graph})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_vertices_path_graph.svg}}
\end{figure}



\section{Working on graphs with custom vertices (as a custom property)}

When using graphs with custom vertices, their state gives a way to
find a vertex and working with it. This chapter shows some basic operations
on graphs with custom vertices.
\begin{itemize}
\item Check if there exists a vertex with a certain 'my\_vertex': chapter
\ref{sub:has_custom_vertex_with_my_vertex}
\item Find a vertex with a certain 'my\_vertex': chapter \ref{sub:find_custom_vertex_with_my_vertex}
\item Get a vertex its 'my\_vertex' from its vertex descriptor: chapter
\ref{sub:get_custom_vertex_my_vertex}
\item Set a vertex its 'my\_vertex' using its vertex descriptor: chapter
\ref{sub:set_custom_vertex_my_vertex}
\item Setting all vertices their 'my\_vertex'es: chapter \ref{sub:set_custom_vertex_my_vertexes}
\item Storing an directed/undirected graph with custom vertices as a .dot
file: chapter \ref{sub:save_custom_vertices_graph_to_dot}
\item Loading a directed graph with custom vertices from a .dot file: chapter
\ref{sub:load_directed_custom_vertices_graph_from_dot}
\item Loading an undirected directed graph with custom vertices from a .dot
file: chapter \ref{sub:load_undirected_custom_vertices_graph_from_dot}
\end{itemize}

\subsection{Has a custom vertex with a my\_vertex\label{sub:has_custom_vertex_with_my_vertex}}

Before modifying our vertices, let's first determine if we can find
a vertex by its custom type ('my\_vertex') in a graph. After obtaing
a my\_vertex map, we obtain the vertex iterators, dereference these
to obtain the vertex descriptors and then compare each vertex its
my\_vertex with the one desired.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_custom_vertex_with_my_vertex.impl}

\caption{Find if there is vertex with a certain my\_vertex\index{Has custom vertex with my_vertex@Has custom vertex with my\_vertex}\label{alg:has_custom_vertex_with_my_vertex}}
\end{algorithm}


This function can be demonstrated as in algorithm \ref{alg:has_vertex_with_my_vertex_demo},
where a certain my\_vertex cannot be found in an empty graph. After
adding the desired my\_vertex, it is found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_custom_vertex_with_my_vertex_demo.impl}

\caption{Demonstration of the 'has\_custom\_vertex\_with\_my\_vertex' function\label{alg:has_vertex_with_my_vertex_demo}}
\end{algorithm}


Note that this function only finds if there is at least one custom
vertex with that my\_vertex: it does not tell how many custom vertices
with that my\_vertex exist in the graph.


\subsection{Find a custom vertex with a certain my\_vertex\label{sub:find_custom_vertex_with_my_vertex}}

Where STL functions work with iterators, here we obtain a vertex descriptor
(see chapter \ref{sub:Vertex-descriptors}) to obtain a handle to
the desired vertex. Algorithm \ref{alg:find_first_custom_vertex_with_my_vertex}
shows how to obtain a vertex descriptor to the first vertex found
with a specific my\_vertex value.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_custom_vertex_with_my_vertex.impl}

\caption{Find the first vertex with a certain my\_vertex\index{Find first custom vertex with my_vertex@Find first custom vertex with my\_vertex}\label{alg:find_first_custom_vertex_with_my_vertex}}
\end{algorithm}


With the vertex descriptor obtained, one can read and modify the vertex
and the edges surrounding it. Algorithm \ref{alg:find_first_custom_vertex_with_my_vertex_demo}
shows some examples of how to do so.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_custom_vertex_with_my_vertex_demo.impl}

\caption{Demonstration of the 'find\_first\_custom\_vertex\_with\_my\_vertex'
function\label{alg:find_first_custom_vertex_with_my_vertex_demo}}
\end{algorithm}



\subsection{Get a custom vertex its my\_vertex\label{sub:get_custom_vertex_my_vertex}}

To obtain the name from a vertex descriptor, one needs to pull out
the my\_vertexes%
\footnote{Bad English intended: my\_vertexes = multiple my\_vertex objects,
vertices = multiple graph nodes%
} map and then look up the vertex of interest.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_custom_vertex.impl}

\caption{Get a my\_custom\_vertex its my\_vertex from its vertex descriptor\index{Get my_custom_vertex@Get my\_custom\_vertex}\label{alg:get_vertex_my_vertex}}
\end{algorithm}


To use 'get\_custom\_vertex\_my\_vertex', one first needs to obtain
a vertex descriptor. Algorithm \ref{alg:get_my_custom_vertex_demo}
shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_custom_vertex_demo.impl}

\caption{Demonstration if the 'get\_my\_custom\_vertex' function\label{alg:get_my_custom_vertex_demo}}
\end{algorithm}



\subsection{Set a custom vertex its my\_vertex\label{sub:set_custom_vertex_my_vertex}}

If you know how to get the my\_vertex from a vertex descriptor, setting
it is just as easy, as shown in algorithm \ref{alg:set_custom_vertex_my_vertex}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_custom_vertex.impl}

\caption{Set a custom vertex its my\_vertex from its vertex descriptor\index{Set my_custom_vertex@Set my\_custom\_vertex}\label{alg:set_custom_vertex_my_vertex}}
\end{algorithm}


To use 'set\_my\_custom\_vertex', one first needs to obtain a vertex
descriptor. Algorithm \ref{alg:set_custom_vertex_my_vertex_demo}
shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_custom_vertex_demo.impl}

\caption{Demonstration if the 'set\_my\_custom\_vertex' function\label{alg:set_custom_vertex_my_vertex_demo}}
\end{algorithm}



\subsection{Setting all custom vertices' my\_vertex objects\label{sub:set_custom_vertex_my_vertexes}}

When the vertices of a graph are associated with my\_vertex objects,
one can set these my\_vertexes as such:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_custom_vertexes.impl}

\caption{Setting the custom vertices' my\_vertexes\index{Set my_custom_vertexes@Set my\_custom\_vertexes}\label{alg:set_my_custom_vertexes}}
\end{algorithm}


An impressive feature is that getting the property map holding the
graph its names is not a copy, but a reference. Otherwise, modifying
'my\_vertexes\_map' (obtained by non-reference) would only modify
a copy.


\subsection{\textifsymbol[ifgeo]{100} Are two graphs with custom vertices isomorphic?\label{sub:is_custom_vertices_isomorphic}}

Algorithm \ref{sub:is_named_vertices_isomorphic} checked if two graphs
with named vertices are 'label isomorphic'. Here, we do the same for
custom vertices.

To do this, there are two steps needed:
\begin{enumerate}
\item Map all my\_custom\_vertex objects to an unsigned int.
\item Compare the two graphs with that map
\end{enumerate}
Below the class 'my\_custom\_vertex\_invariant' is shown. Its std::map
maps the vertex names to an unsigned integer, which is done in the
member function 'collect\_names'. The purpose of this, is that is
is easier to compare integers than custom vertices. Note that operator<\index{operator<}
must be implemented for the custom class for this to compile.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{custom_vertex_invariant.impl}

\caption{The 'custom\_vertex\_invariant' functor\index{custom_vertex_invariant@custom\_vertex\_invariant}\label{alg:custom_vertex_invariant}}
\end{algorithm}


To check for 'custom vertexness isomorphism', multiple things need
to be put in place for 'boost::isomorphism'\index{boost::isomorphism}
to work with:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{is_custom_vertices_isomorphic.impl}

\caption{Check if two graphs with custom vertices are isomorphic\index{Is isomorphic}\label{alg:is_custom_vertices_isomorphic}}
\end{algorithm}


This demonstration code creates three path graphs, of which two are
'label isomorphic':

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{is_custom_vertices_isomorphic_demo.impl}

\caption{Demo of the 'is\_named\_vertices\_isomorphic' function\label{alg:is_named_vertices_isomorphic_demo-1}}
\end{algorithm}



\subsection{Storing a graph with custom vertices as a .dot\label{sub:save_custom_vertices_graph_to_dot}}

If you used the create\_custom\_vertices\_k2\_graph function (algorithm
\ref{alg:create_custom_vertices_k2_graph}) to produce a $K_{2}$
graph with vertices associated with my\_vertex objects, you can store
these my\_vertexes additionally with algorithm \ref{alg:save_custom_vertices_graph_to_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_custom_vertices_graph_to_dot.impl}

\caption{Storing a graph with custom vertices as a .dot file\index{Save custom vertices graph to dot}\label{alg:save_custom_vertices_graph_to_dot}}
\end{algorithm}



\subsection{Loading a directed graph with custom vertices from a .dot\label{sub:load_directed_custom_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph with custom vertices is loaded,
as shown in algorithm \ref{alg:load_directed_custom_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_custom_vertices_graph_from_dot.impl}

\caption{Loading a directed graph with custom vertices from a .dot file\index{Load directed custom vertices graph from dot}\label{alg:load_directed_custom_vertices_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists.
Then an empty directed graph is created. Next to this, a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with its default constructor, after which we direct the
boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
to find a 'node\_id' and 'label' in the vertex name map, 'edge\_id'
and 'label to the edge name map. From this and the empty graph, 'boost::read\_graphviz'\index{boost::read_graphviz@boost::read\_graphviz}
is called to build up the graph.

Algorithm \ref{alg:load_directed_custom_vertices_graph_from_dot_demo}
shows how to use the 'load\_directed\_custom\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_custom_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_custom\_vertices\_graph\_from\_dot'
function\label{alg:load_directed_custom_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_custom\_vertices\_markov\_chain' function (algorithm \ref{alg:create_custom_vertices_markov_chain}),
saved and then loaded. The loaded graph is then checked to be identical
to the original.


\subsection{Loading an undirected graph with custom vertices from a .dot\label{sub:load_undirected_custom_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an undirected graph with custom vertices is loaded,
as shown in algorithm \ref{alg:load_undirected_custom_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_custom_vertices_graph_from_dot.impl}

\caption{Loading an undirected graph with custom vertices from a .dot file\index{Load undirected custom vertices graph from dot}\label{alg:load_undirected_custom_vertices_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:load_directed_custom_vertices_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_custom_vertices_graph_from_dot_demo-1}
shows how to use the 'load\_undirected\_custom\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_custom_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_custom\_vertices\_graph\_from\_dot'
function\label{alg:load_undirected_custom_vertices_graph_from_dot_demo-1}}
\end{algorithm}


This demonstration shows how $K_{2}$ with custom vertices is created
using the 'create\_custom\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_custom_vertices_k2_graph}), saved and then loaded.
The loaded graph is then checked to be identical to the original.


\section{Building graphs with custom and selectable vertices}

We have added one custom vertex property, here we add a second: if
the vertex is selected.
\begin{itemize}
\item An empty directed graph that allows for custom and selectable vertices:
see chapter \ref{sub:create_empty_directed_custom_and_selectable_vertices_graph}
\item An empty undirected graph that allows for custom and selectable vertices:
see chapter \ref{sub:create_empty_undirected_custom_and_selectable_vertices_graph}
\item A two-state Markov chain with custom and selectable vertices: see
chapter \ref{sub:create_custom_and_selectable_vertices_markov_chain}
\item $K_{3}$with custom and selectable vertices: see chapter \ref{sub:create_custom_and_selectable_vertices_k2_graph}
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Installing the new edge property: see chapter \ref{sub:install_is_selected}
\item Adding a custom and selectable vertex: see chapter \ref{sub:add_custom_and_selectable_vertex}
\end{itemize}
These functions are mostly there for completion and showing which
data types are used.


\subsection{Installing the new is\_selected property\label{sub:install_is_selected}\index{vertex_is_selected@vertex\_is\_selected}\index{vertex_is_selected_t@vertex\_is\_selected\_t}}

Installing a new property would have been easier, if 'more C++ compilers
were standards conformant' (\cite{siek2001boost}, chapter 3.6, footnote
at page 52). Boost.Graph uses the BOOST\_INSTALL\_PROPERTY\index{BOOST_INSTALL_PROPERTY@BOOST\_INSTALL\_PROPERTY}
macro\index{macro} to allow using a custom property:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{install_vertex_is_selected.impl}

\caption{Installing the vertex\_is\_selected property\index{Install vertex_is_selected@Install vertex\_is\_selected}\label{alg:install_vertex_is_selected}}
\end{algorithm}


The enum value 31415 must be unique.


\subsection{Create an empty directed graph with custom and selectable vertices\label{sub:create_empty_directed_custom_and_selectable_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_custom_and_selectable_vertices_graph.impl}

\caption{Creating an empty directed graph with custom and selectable vertices\index{Create empty directed custom and selectable vertices graph}\label{alg:create_empty_directed_custom_and_selectable_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_custom_vertices_graph},
except that there is a new, fourth template argument:

\begin{lstlisting}
boost::property<boost::vertex_custom_type_t, my_custom_vertex, 
  boost::property<boost::vertex_is_selected_t, bool, 
>
\end{lstlisting}
This can be read as: ``vertices have two properties: an associated
custom type (of type my\_custom\_vertex) and an associated is\_selected
property (of type bool)''.

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_custom_and_selectable_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_directed\_custom\_and\_selectable\_vertices\_graph'
function\label{alg:create_empty_directed_custom_and_selectable_vertices_graph_demo}}
\end{algorithm}



\subsection{Create an empty undirected graph with custom and selectable vertices\label{sub:create_empty_undirected_custom_and_selectable_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_custom_and_selectable_vertices_graph.impl}

\caption{Creating an empty undirected graph with custom and selectable vertices\index{Create empty undirected custom and selectable vertices graph}\label{alg:create_empty_undirected_custom_and_selectable_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_custom_and_selectable_vertices_graph},
except that the directedness (the third template argument) is undirected
(due to the boost::undirectedS\index{boost::undirectedS}).

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_custom_and_selectable_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_undirected\_custom\_and\_selectable\_vertices\_graph'
function\label{alg:create_empty_undirected_custom_and_selectable_vertices_graph_demo}}
\end{algorithm}



\subsection{Add a custom and selectable vertex\label{sub:add_custom_and_selectable_vertex}}

Adding a custom and selectable vertex is very similar to adding a
custom vertex (chapter \ref{sub:add_custom_vertex}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_custom_and_selectable_vertex.impl}

\caption{Add a custom and selectable vertex\index{Add custom and selectable vertex}\label{alg:add_custom_and_selactable_vertex}}
\end{algorithm}


When having added a new (abstract) vertex to the graph, the vertex
descriptor is used to set the my\_custom\_vertex and the selectedness
in the graph its my\_custom\_vertex and is\_selected map .

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_custom_and_selectable_vertex_demo.impl}

\caption{Demo of 'add\_custom\_and\_selectable\_vertex'\label{alg:add_custom_and_selectable_vertex_demo}}
\end{algorithm}



\subsection{Creating a Markov-chain with custom and selectable vertices\label{sub:create_custom_and_selectable_vertices_markov_chain}}


\subsubsection{Graph}

Figure \ref{fig:create_custom_and_selectable_vertices_markov_chain}
shows the graph that will be reproduced:

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm, semithick]   
  \tikzstyle{every state}=[]
  \node[state] (A) 
    {Sunny, You [...], 1.0, 2.0};   
  \node[state] (B) [right of=A] 
    {Rainy, Many [...], 3.0, 4.0}
  ;   
  \path (A) edge [loop above] node {AA,self,1,2} (A)
        (A) edge [bend  left] node {AB,nonself,3,4} (B)
        (B) edge [bend  left] node {BA,nonself,4,5} (A)
        (B) edge [loop above] node {BB,self,6,7} (B); 
\end{tikzpicture}

\caption{A two-state Markov chain where the edges and vertices have custom
properies. The edges' and vertices' properties are nonsensical\label{fig:create_custom_and_selectable_vertices_markov_chain}}
\end{figure}



\subsubsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with custom edges
and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_and_selectable_vertices_markov_chain.impl}

\caption{Creating the two-state Markov chain as depicted in figure \ref{fig:create_custom_and_selectable_vertices_markov_chain}\index{Create custom and selectable vertices Markov chain}\label{alg:create_custom_and_selectable_vertices_markov_chain}}
\end{algorithm}



\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_and_selectable_vertices_markov_chain_demo.impl}

\caption{Demo of the 'create\_custom\_and\_selectable\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_and_selectable_vertices_markov_chain})\label{alg:create_custom_and_selectable_vertices_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_custom_and_selectable_vertices_markov_chain.dot}

\caption{.dot file created from the 'create\_custom\_and\_selectable\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_and_selectable_vertices_markov_chain}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_custom_and_selectable_vertices_markov_chain.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_custom_and_selectable_vertices_markov_chain}

\caption{.svg file created from the 'create\_custom\_and\_selectable\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_and_selectable_vertices_markov_chain.svg}}
\end{figure}


Note how the .svg changed it appearance due to the Graphviz 'regular'
property (see chapter \ref{sub:Graphviz-attributes}): the vertex
labeled 'Sunny' is drawn according to the Graphviz 'regular' attribute,
which makes it a circle. The other vertex, labeled 'Rainy' is not
drawn as such and retained its ellipsoid appearance. 


\subsection{Creating $K_{2}$ with custom and selectable vertices\label{sub:create_custom_and_selectable_vertices_k2_graph}}


\subsubsection{Graph}

We reproduce the $K_{2}$ with custom vertices of chapter \ref{sub:create_custom_vertices_k2_graph}
, but now are vertices can be selected as well:

{[}graph here{]}


\subsubsection{Function to create such a graph}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_and_selectable_vertices_k2_graph.impl}

\caption{Creating $K_{3}$ as depicted in figure \ref{fig:named_edges_and_vertices_k3}\index{Create custom and selectable vertices K2 graph}\label{alg:create_custom_and_selectable_vertices_k2_graph}}
\end{algorithm}


Most of the code is a slight modification of algorithm \ref{alg:create_custom_vertices_k2_graph}.
In the end, the associated my\_custom\_vertex and is\_selected properties
are obtained as boost::property\_maps and set with the desired my\_custom\_vertex
objects and selectednesses.


\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_and_selectable_vertices_k2_graph_demo.impl}

\caption{Demo of the 'create\_custom\_and\_selectable\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_custom_and_selectable_vertices_k2_graph})\label{alg:create_custom_and_selectable_vertices_k2_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_custom_and_selectable_vertices_k2_graph.dot}

\caption{.dot file created from the 'create\_custom\_and\_selectable\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_custom_and_selectable_vertices_k2_graph}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_custom_and_selectable_vertices_k2_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_custom_and_selectable_vertices_k2_graph}

\caption{.svg file created from the 'create\_custom\_and\_selectable\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_and_selectable_vertices_k2_graph.svg}}
\end{figure}


Note how the .svg changed it appearance due to the Graphviz 'regular'
property (see chapter \ref{sub:Graphviz-attributes}): the vertex
labeled 'A' is drawn according to the Graphviz 'regular' attribute,
which makes it a circle. The other vertex, labeled 'B' is not drawn
as such and retained its ellipsoid appearance.


\section{Working on graphs with custom and selectable vertices}

This chapter shows some basic operations to do on graphs with custom
and selectable vertices.
\begin{itemize}
\item Storing an directed/undirected graph with custom and selectable vertices
as a .dot file: chapter \ref{sub:save_custom_and_selectable_vertices_graph_to_dot}
\item Loading a directed graph with custom and selectable vertices from
a .dot file: chapter \ref{sub:load_directed_custom_and_selectable_vertices_graph_from_dot}
\item Loading an undirected directed graph with custom and selectable vertices
from a .dot file: chapter \ref{sub:load_undirected_custom_and_selectable_vertices_graph_from_dot}
\end{itemize}

\subsection{Storing a graph with custom and selectable vertices as a .dot\label{sub:save_custom_and_selectable_vertices_graph_to_dot}}

If you used the 'create\_custom\_and\_selectable\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_custom_and_selectable_vertices_k2_graph})
to produce a $K_{2}$ graph with vertices associated with (1) my\_custom\_vertex
objects, and (2) a boolean indicating its selectedness, you can store
such graphs with algorithm \ref{alg:save_custom_and_selectable_vertices_graph_to_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_custom_and_selectable_vertices_graph_to_dot.impl}

\caption{Storing a graph with custom and selectable vertices as a .dot file\index{Save custom vertices graph to dot}\label{alg:save_custom_and_selectable_vertices_graph_to_dot}}
\end{algorithm}


This code looks small, because we call the 'make\_custom\_and\_selectable\_vertices\_writer'
function, which is shown in algorithm \ref{alg:make_custom_and_selectable_vertices_writer}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{make_custom_and_selectable_vertices_writer.impl}

\caption{The 'make\_custom\_and\_selectable\_vertices\_writer' function\index{make_custom_and_selectable_vertices_writer@make\_custom\_and\_selectable\_vertices\_writer}\label{alg:make_custom_and_selectable_vertices_writer}}
\end{algorithm}


Also this function is forwarding the real work to the 'custom\_and\_selectable\_vertices\_writer',
shown in algorithm \ref{alg:custom_and_selectable_vertices_writer}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{custom_and_selectable_vertices_writer.impl}

\caption{The 'custom\_and\_selectable\_vertices\_writer' function\index{custom_and_selectable_vertices_writer@custom\_and\_selectable\_vertices\_writer}\label{alg:custom_and_selectable_vertices_writer}}
\end{algorithm}


Here, some interesting things are happening: the writer needs both
property maps to work with (that is, the 'my\_custom\_vertex' and
is\_selected maps). The 'my\_custom\_vertex' are written to the Graphviz
'label' attribute, and the is\_selected is written to the 'regular'
attribute (see chapter \ref{sub:Graphviz-attributes} for most Graphviz
attributes).

Special about this, is that even for Graphviz-unfriendly input, it
still works.


\subsection{Loading a directed graph with custom and selectable vertices from
a .dot\label{sub:load_directed_custom_and_selectable_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph with custom and selectable vertices
is loaded, as shown in algorithm \ref{alg:load_directed_custom_and_selectable_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_custom_and_selectable_vertices_graph_from_dot.impl}

\caption{Loading a directed graph with custom vertices from a .dot file\index{Load directed custom vertices graph from dot}\label{alg:load_directed_custom_and_selectable_vertices_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists.
Then an empty directed graph is created. Then, a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with its default constructor, after which 
\begin{itemize}
\item The Graphviz attribute 'node\_id' (see chapter \ref{sub:Graphviz-attributes}
for most Graphviz attributes) is connected to a vertex its 'my\_custom\_vertex'
property
\item The Graphviz attribute 'label' is connected to a vertex its 'my\_custom\_vertex'
property
\item The Graphviz attribute 'regular' is connected to a vertex its 'is\_selected'
vertex property
\end{itemize}
Algorithm \ref{alg:load_directed_custom_and_selectable_vertices_graph_from_dot_demo}
shows how to use the 'load\_directed\_custom\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_custom_and_selectable_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_custom\_and\_selectable\_vertices\_graph\_from\_dot'
function\label{alg:load_directed_custom_and_selectable_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_custom\_vertices\_markov\_chain' function (algorithm \ref{alg:create_custom_vertices_markov_chain}),
saved and then checked to exist.


\subsection{Loading an undirected graph with custom and selectable vertices from
a .dot\label{sub:load_undirected_custom_and_selectable_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an undirected graph with custom and selectable vertices
is loaded, as shown in algorithm \ref{alg:load_undirected_custom_and_selectable_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_custom_and_selectable_vertices_graph_from_dot.impl}

\caption{Loading an undirected graph with custom vertices from a .dot file\index{Load undirected custom vertices graph from dot}\label{alg:load_undirected_custom_and_selectable_vertices_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:load_directed_custom_and_selectable_vertices_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_custom_and_selectable_vertices_graph_from_dot_demo}
shows how to use the 'load\_undirected\_custom\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_custom_and_selectable_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_custom\_and\_selectable\_vertices\_graph\_from\_dot'
function\label{alg:load_undirected_custom_and_selectable_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how $K_{2}$ with custom vertices is created
using the 'create\_custom\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_custom_vertices_k2_graph}), saved and then checked
to exist.


\section{Building graphs with custom edges and vertices}

Up until now, the graphs created have had edges and vertices with
the built-in name property. In this chapter, graphs will be created,
in which the edges and vertices can have a custom 'my\_custom\_edge'
and 'my\_custom\_edge' type%
\footnote{I do not intend to be original in naming my data types%
}.
\begin{itemize}
\item An empty directed graph that allows for custom edges and vertices:
see chapter \ref{sub:create_empty_directed_custom_edges_and_vertices_graph}
\item An empty undirected graph that allows for custom edges and vertices:
see chapter \ref{sub:create_empty_undirected_custom_edges_and_vertices_graph}
\item A two-state Markov chain with custom edges and vertices: see chapter
\ref{sub:create_custom_edges_and_vertices_markov_chain}
\item $K_{3}$with custom edges and vertices: see chapter \ref{sub:create_custom_edges_and_vertices_k3}
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Creating the custom edge class: see chapter \ref{sub:my_custom_edge}
\item Installing the new edge property: see chapter \ref{sub:install_edge_custom_type}
\item Adding a custom edge: see chapter \ref{sub:add_custom_edge}
\end{itemize}
These functions are mostly there for completion and showing which
data types are used.


\subsection{Creating the custom edge class\label{sub:my_custom_edge}}

In this example, I create a custom edge class. Here I will show the
header file of it, as the implementation of it is not important yet.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{my_custom_edge.impl}

\caption{Declaration of my\_custom\_edge\index{my_custom_edge@my\_custom\_edge}\index{my_custom_edge.h@my\_custom\_edge.h}\index{my_custom_edge declaration@my\_custom\_edge declaration}\index{Declaration, my_custom_edge@Declaration, my\_custom\_edge}\label{alg:my_custom_edge_h}}
\end{algorithm}


my\_custom\_edge is a class that has multiple properties: two doubles
'm\_width' ('m\_\index{m_@m\_}' stands for member\index{member})
and 'm\_height', and two std::strings m\_name and m\_description.
'my\_custom\_edge' is copyable, but cannot trivially be converted
to a std::string.' 'my\_custom\_edge' is comparable for equality (that
is, operator== is defined).

Special characters like comma's, quotes and whitespace cannot be streamed
without problems. The function 'graphviz\_encode' (algorithm \ref{alg:graphviz_encode})
can convert the elements to be streamed to a Graphviz-friendly version,
which can be decoded by 'graphviz\_decode' (algorithm \ref{alg:graphviz_decode}).


\subsection{Installing the new edge property\label{sub:install_edge_custom_type}}

Installing a new property would have been easier, if 'more C++ compilers
were standards conformant' (\cite{siek2001boost}, chapter 3.6, footnote
at page 52). Boost.Graph uses the BOOST\_INSTALL\_PROPERTY\index{BOOST_INSTALL_PROPERTY@BOOST\_INSTALL\_PROPERTY}
macro\index{macro} to allow using a custom property:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{install_edge_custom_type.impl}

\caption{Installing the edge\_custom\_type property\index{Install edge custom type}\label{alg:install_edge_custom_type}}
\end{algorithm}


The enum value 3142 must be unique.


\subsection{Create an empty directed graph with custom edges and vertices\label{sub:create_empty_directed_custom_edges_and_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_custom_edges_and_vertices_graph.impl}

\caption{Creating an empty directed graph with custom edges and vertices\index{Create empty directed custom edges and vertices graph}\label{alg:create_empty_directed_custom_edges_and_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_custom_vertices_graph},
except that there is a new, fifth template argument:

\begin{lstlisting}
boost::property<boost::edge_custom_type_t, my_edge>
\end{lstlisting}
\index{boost::property}\index{boost::edge_custom_type_t@boost::edge\_custom\_type\_t}\index{my_edge@my\_edge}This
can be read as: ``edges have the property 'boost::edge\_custom\_type\_t',
which is of data type 'my\_custom\_edge'''. Or simply: ``edges have
a custom type called my\_custom\_edge''.

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_custom_edges_and_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_directed\_custom\_edges\_and\_vertices\_graph'
function\label{alg:create_empty_directed_custom_edges_and_vertices_graph_demo}}
\end{algorithm}



\subsection{Create an empty undirected graph with custom edges and vertices\label{sub:create_empty_undirected_custom_edges_and_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_custom_edges_and_vertices_graph.impl}

\caption{Creating an empty undirected graph with custom edges and vertices\index{Create empty undirected custom edges and vertices graph}\label{alg:create_empty_undirected_custom_edges_and_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_custom_edges_and_vertices_graph},
except that the directedness (the third template argument) is undirected
(due to the boost::undirectedS\index{boost::undirectedS}).

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_custom_edges_and_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_undirected\_custom\_edges\_and\_vertices\_graph'
function\label{alg:create_empty_undirected_custom_edges_and_vertices_graph_demo}}
\end{algorithm}



\subsection{Add a custom edge\label{sub:add_custom_edge}}

Adding a custom edge is very similar to adding a named edge (chapter
\ref{sub:add_named_edge}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_custom_edge.impl}

\caption{Add a custom edge\index{Add custom edge}\label{alg:add_custom_edge}}
\end{algorithm}


When having added a new (abstract) edge to the graph, the edge descriptor
is used to set the my\_edge in the graph its my\_custom\_edge map
(using 'get(boost::edge\_custom\_type,g)\index{boost::edge_custom_type@boost::edge\_custom\_type}\index{get}').

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_custom_edge_demo.impl}

\caption{Demo of 'add\_custom\_edge'\label{alg:add_custom_edge_demo}}
\end{algorithm}



\subsection{Getting the custom edges my\_edges\label{sub:get_custom_edge_my_edges}}

When the edges of a graph have an associated 'my\_custom\_edge', one
can extract these all as such:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_custom_edges.impl}

\caption{Get the edges' my\_custom\_edges\index{Get edge my_custom_edges@Get edge my\_custom\_edges}\label{alg:get_custom_edge_my_edges}}
\end{algorithm}


The 'my\_custom\_edge' object associated with the edges are obtained
from a boost::property\_map and then put into a std::vector.

Note: the order of the my\_custom\_edge objects may be different after
saving and loading.

When trying to get the edges' my\_custom\_edge objects from a graph
without custom edges objects associated, you will get the error 'formed
reference to void' (see chapter \ref{sub:formed_reference_to_void}).


\subsection{Creating a Markov-chain with custom edges and vertices\label{sub:create_custom_edges_and_vertices_markov_chain}}


\subsubsection{Graph}

Figure \ref{fig:custom_edges_and_vertices_markov_chain} shows the
graph that will be reproduced:

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm, semithick]   
  \tikzstyle{every state}=[]
  \node[state] (A) 
    {Sunny, You [...], 1.0, 2.0};   
  \node[state] (B) [right of=A] 
    {Rainy, Many [...], 3.0, 4.0}
  ;   
  \path (A) edge [loop above] node {AA,self,1,2} (A)
        (A) edge [bend  left] node {AB,nonself,3,4} (B)
        (B) edge [bend  left] node {BA,nonself,4,5} (A)
        (B) edge [loop above] node {BB,self,6,7} (B); 
\end{tikzpicture}

\caption{A two-state Markov chain where the edges and vertices have custom
properies. The edges' and vertices' properties are nonsensical\label{fig:custom_edges_and_vertices_markov_chain}}
\end{figure}



\subsubsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with custom edges
and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_edges_and_vertices_markov_chain.impl}

\caption{Creating the two-state Markov chain as depicted in figure \ref{fig:custom_edges_and_vertices_markov_chain}\index{Create custom edges and vertices Markov chain}\label{alg:create_custom_edges_and_vertices_markov_chain}}
\end{algorithm}



\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_edges_and_vertices_markov_chain_demo.impl}

\caption{Demo of the 'create\_custom\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_edges_and_vertices_markov_chain})\label{alg:create_custom_edges_and_vertices_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_custom_edges_and_vertices_markov_chain.dot}

\caption{.dot file created from the 'create\_custom\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_edges_and_vertices_markov_chain}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_custom_edges_and_vertices_markov_chain.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_custom_edges_and_vertices_markov_chain}

\caption{.svg file created from the 'create\_custom\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_edges_and_vertices_markov_chain.svg}}
\end{figure}



\subsection{Creating $K_{3}$ with custom edges and vertices\label{sub:create_custom_edges_and_vertices_k3}}

Instead of using edges with a name, or other properties, here we use
a custom edge class called 'my\_custom\_edge'.


\subsubsection{Graph}

We reproduce the $K_{3}$ with named edges and vertices of chapter
\ref{sub:create_named_edges_and_vertices_k3} , but with our custom
edges and vertices intead:

{[}graph here{]}


\subsubsection{Function to create such a graph}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_edges_and_vertices_k3_graph.impl}

\caption{Creating $K_{3}$ as depicted in figure \ref{fig:named_edges_and_vertices_k3}\index{Create custom edges and vertices K3 graph}\label{alg:create_custom_edges_and_vertices_k3_graph}}
\end{algorithm}


Most of the code is a slight modification of algorithm \ref{alg:create_named_edges_and_vertices_k3_graph}.
In the end, the my\_edges and my\_vertices are obtained as a boost::property\_map
and set with the 'my\_custom\_edge' and 'my\_custom\_vertex' objects.


\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_edges_and_vertices_k3_graph_demo.impl}

\caption{Demo of the 'create\_custom\_edges\_and\_vertices\_k3\_graph' function
(algorithm \ref{alg:create_custom_edges_and_vertices_k3_graph})\label{alg:create_custom_edges_and_vertices_k3_graph_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_custom_edges_and_vertices_k3_graph.dot}

\caption{.dot file created from the 'create\_custom\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_edges_and_vertices_k3_graph}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_custom_edges_and_vertices_k3_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_custom_edges_and_vertices_k3_graph}

\caption{.svg file created from the 'create\_custom\_edges\_and\_vertices\_k3\_graph'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_edges_and_vertices_k3_graph.svg}}
\end{figure}



\section{Working on graphs with custom edges and vertices}


\subsection{Has a my\_custom\_edge\label{sub:has_custom_edge_with_my_edge}}

Before modifying our edges, let's first determine if we can find an
edge by its custom type ('my\_custom\_edge') in a graph. After obtaing
a my\_custom\_edge map, we obtain the edge iterators, dereference
these to obtain the edge descriptors and then compare each edge its
my\_custom\_edge with the one desired.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_custom_edge_with_my_edge.impl}

\caption{Find if there is a custom edge with a certain my\_custom\_edge\index{Has custom edge with my_custom_edge@Has custom edge with my\_custom\_edge}\label{alg:has_custom_edge_with_my_edge}}
\end{algorithm}


This function can be demonstrated as in algorithm \ref{alg:has_custom_edge_with_my_edge_demo},
where a certain 'my\_custom\_edge' cannot be found in an empty graph.
After adding the desired my\_custom\_edge, it is found.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{has_custom_edge_with_my_edge_demo.impl}

\caption{Demonstration of the 'has\_custom\_edge\_with\_my\_edge' function\label{alg:has_custom_edge_with_my_edge_demo}}
\end{algorithm}


Note that this function only finds if there is at least one edge with
that my\_custom\_edge: it does not tell how many edges with that my\_custom\_edge
exist in the graph.


\subsection{Find a my\_custom\_edge\label{sub:find_first_custom_edge_with_my_edge}}

Where STL functions work with iterators, here we obtain an edge descriptor
(see chapter \ref{sub:Edge-descriptors}) to obtain a handle to the
desired edge. Algorithm \ref{alg:find_first_edge_with_my_custom_edge}
shows how to obtain an edge descriptor to the first edge found with
a specific my\_custom\_edge value.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_custom_edge_with_my_edge.impl}

\caption{Find the first custom edge with a certain my\_custom\_edge\index{Find first custom edge with my_custom_edge@Find first custom edge with my\_custom\_edge}\label{alg:find_first_edge_with_my_custom_edge}}
\end{algorithm}


With the edge descriptor obtained, one can read and modify the edge
and the vertices surrounding it. Algorithm \ref{alg:find_first_edge_with_my_custom_edge_demo}
shows some examples of how to do so.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{find_first_custom_edge_with_my_edge_demo.impl}

\caption{Demonstration of the 'find\_first\_custom\_edge\_with\_my\_edge' function\label{alg:find_first_edge_with_my_custom_edge_demo}}
\end{algorithm}



\subsection{Get an edge its my\_custom\_edge\label{sub:get_custom_edge_my_edge}}

To obtain the my\_edeg from an edge descriptor, one needs to pull
out the my\_custom\_edges map and then look up the my\_edge of interest.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_custom_edge.impl}

\caption{Get a vertex its my\_custom\_vertex from its vertex descriptor\index{Get custom edge my_custom_edge@Get custom edge my\_custom\_edge}\label{alg:get_custom_edge_my_edge}}
\end{algorithm}


To use 'get\_custom\_edge\_my\_custom\_edge', one first needs to obtain
an edge descriptor. Algorithm \ref{alg:get_custom_edge_my_edge_demo}
shows a simple example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_my_custom_edge_demo.impl}

\caption{Demonstration if the 'get\_custom\_edge\_my\_edge' function\label{alg:get_custom_edge_my_edge_demo}}
\end{algorithm}



\subsection{Set an edge its my\_custom\_edge\label{sub:set_custom_edge_my_edge}}

If you know how to get the my\_custom\_edge from an edge descriptor,
setting it is just as easy, as shown in algorithm \ref{alg:set_edge_my_custom_edge}.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_custom_edge.impl}

\caption{Set a custom edge its my\_custom\_edge from its edge descriptor\index{Set my_custom_edge@Set my\_custom\_edge}\label{alg:set_edge_my_custom_edge}}
\end{algorithm}


To use 'set\_my\_custom\_edge', one first needs to obtain an edge
descriptor. Algorithm \ref{alg:set_my_custom_edge_demo} shows a simple
example.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_my_custom_edge_demo.impl}

\caption{Demonstration if the 'set\_my\_custom\_edge' function\label{alg:set_my_custom_edge_demo}}
\end{algorithm}



\subsection{Storing a graph with custom edges and vertices as a .dot\label{sub:save_custom_edges_and_vertices_graph_to_dot}\index{Save graph with custom edges and vertices as .dot}\index{Create .dot from graph with custom edges and vertices} }

If you used the create\_custom\_edges\_and\_vertices\_k3\_graph function
(algorithm \ref{alg:create_custom_edges_and_vertices_k3_graph}) to
produce a $K_{3}$ graph with edges and vertices associated with my\_custom\_edge
and my\_custom\_vertex objects, you can store these my\_custom\_edges
and my\_custom\_vertex-es additionally with algorithm \ref{alg:save_custom_edges_and_vertices_graph_to_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_custom_edges_and_vertices_graph_to_dot.impl}

\caption{Storing a graph with custom edges and vertices as a .dot file\index{Save custom edges and vertices graph to dot}\label{alg:save_custom_edges_and_vertices_graph_to_dot}}
\end{algorithm}



\subsection{Load a directed graph with custom edges and vertices from a .dot
file\label{sub:sub:load_directed_custom_edges_and_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph with custom edges and vertices
is loaded, as shown in algorithm \ref{alg:load_directed_custom_edges_and_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_custom_edges_and_vertices_graph_from_dot.impl}

\caption{Loading a directed graph with custom edges and vertices from a .dot
file\index{Load directed custom edges and vertices graph from dot}\label{alg:load_directed_custom_edges_and_vertices_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists.
Then an empty directed graph is created. Next to this, a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with its default constructor, after which we direct the
boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
to find a 'node\_id' and 'label' in the vertex name map, 'edge\_id'
and 'label to the edge name map. From this and the empty graph, 'boost::read\_graphviz'\index{boost::read_graphviz@boost::read\_graphviz}
is called to build up the graph.

Algorithm \ref{alg:load_directed_custom_edges_and_vertices_graph_from_dot_demo}
shows how to use the 'load\_directed\_custom\_edges\_and\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_custom_edges_and_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_custom\_edges\_and\_vertices\_graph\_from\_dot'
function\label{alg:load_directed_custom_edges_and_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_custom\_edges\_and\_vertices\_markov\_chain' function (algorithm
\ref{alg:create_custom_edges_and_vertices_markov_chain}), saved and
then loaded.


\subsection{Load an undirected graph with custom edges and vertices from a .dot
file\label{sub:load_undirected_custom_edges_and_vertices_graph_from_dot}\index{Load undirected graph with custom edges and vertices from .dot}\index{Create undirected graph with custom edges and vertices from .dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an undirected graph with custom edges and vertices
is loaded, as shown in algorithm \ref{alg:load_undirected_custom_edges_and_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_custom_edges_and_vertices_graph_from_dot.impl}

\caption{Loading an undirected graph with custom edges and vertices from a
.dot file\index{Load undirected custom edges and vertices graph from dot}\label{alg:load_undirected_custom_edges_and_vertices_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:sub:load_directed_custom_edges_and_vertices_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_custom_edges_and_vertices_graph_from_dot_demo}
shows how to use the 'load\_undirected\_custom\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_custom_edges_and_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_custom\_edges\_and\_vertices\_graph\_from\_dot'
function\label{alg:load_undirected_custom_edges_and_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how $K_{2}$ with custom vertices is created
using the 'create\_custom\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_custom_vertices_k2_graph}), saved and then loaded.
The loaded graph is checked to be a graph similar to the original.


\section{Building graphs with custom and selectable edges and vertices}

Now also the edge can be selected
\begin{itemize}
\item An empty directed graph that allows for custom and selectable vertices:
see chapter \ref{sub:create_empty_directed_custom_and_selectable_edges_and_vertices_graph}
\item An empty undirected graph that allows for custom and selectable vertices:
see chapter \ref{sub:create_empty_undirected_custom_and_selectable_edges_and_vertices_graph}
\item A two-state Markov chain with custom and selectable vertices: see
chapter \ref{sub:create_custom_and_selectable_edges_and_vertices_markov_chain}
\item $K_{3}$with custom and selectable vertices: see chapter \ref{sub:create_custom_and_selectable_edges_and_vertices_k2_graph}
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Installing the new edge property: see chapter \ref{sub:install_is_selected-1}
\item Adding a custom and selectable vertex: see chapter \ref{sub:add_custom_and_selectable_edge}
\end{itemize}
These functions are mostly there for completion and showing which
data types are used.


\subsection{Installing the new is\_selected property\label{sub:install_is_selected-1}\index{edge_is_selected@edge\_is\_selected}\index{edge_is_selected_t@edge\_is\_selected\_t}}

Installing a new property would have been easier, if 'more C++ compilers
were standards conformant' (\cite{siek2001boost}, chapter 3.6, footnote
at page 52). Boost.Graph uses the BOOST\_INSTALL\_PROPERTY\index{BOOST_INSTALL_PROPERTY@BOOST\_INSTALL\_PROPERTY}
macro\index{macro} to allow using a custom property:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{install_edge_is_selected.impl}

\caption{Installing the edge\_is\_selected property\index{Install edge_is_selected@Install edge\_is\_selected}\label{alg:install_edge_is_selected}}
\end{algorithm}


The enum value 31415 must be unique.


\subsection{Create an empty directed graph with custom and selectable edges and
vertices\label{sub:create_empty_directed_custom_and_selectable_edges_and_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_custom_and_selectable_edges_and_vertices_graph.impl}

\caption{Creating an empty directed graph with custom and selectable edges
and vertices\index{Create empty directed custom and selectable edges and vertices graph}\label{alg:create_empty_directed_custom_and_selectable_edges_and_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_custom_vertices_graph},
except that there is a new, fifth template argument:

\begin{lstlisting}
boost::property<boost::edge_custom_type_t, my_custom_edge, 
  boost::property<boost::edge_is_selected_t, bool, 
>
\end{lstlisting}
This can be read as: ``edges have two properties: an associated custom
type (of type my\_custom\_edge) and an associated is\_selected property
(of type bool)''.

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_custom_and_selectable_edges_and_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_directed\_custom\_and\_selectable\_edges\_and\_vertices\_graph'
function\label{alg:create_empty_directed_custom_and_selectable_edges_and_vertices_graph_demo}}
\end{algorithm}



\subsection{Create an empty undirected graph with custom and selectable edges
and vertices\label{sub:create_empty_undirected_custom_and_selectable_edges_and_vertices_graph}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_custom_and_selectable_edges_and_vertices_graph.impl}

\caption{Creating an empty undirected graph with custom and selectable edges
and vertices\index{Create empty undirected custom and selectable edges and vertices graph}\label{alg:create_empty_undirected_custom_and_selectable_edges_and_vertices_graph}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{sub:create_empty_directed_custom_and_selectable_edges_and_vertices_graph},
except that the directedness (the third template argument) is undirected
(due to the boost::undirectedS\index{boost::undirectedS}).

Demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_custom_and_selectable_edges_and_vertices_graph_demo.impl}

\caption{Demonstration of the 'create\_empty\_undirected\_custom\_and\_selectable\_edges\_and\_vertices\_graph'
function\label{alg:create_empty_undirected_custom_and_selectable_edges_and_vertices_graph_demo}}
\end{algorithm}



\subsection{Add a custom and selectable edge\label{sub:add_custom_and_selectable_edge}}

Adding a custom and selectable edge is very similar to adding a custom
and selectable vertex (chapter \ref{sub:add_custom_and_selectable_vertex}).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_custom_and_selectable_edge.impl}

\caption{Add a custom and selectable edge\index{Add custom and selectable edge}\label{alg:add_custom_and_selectable_edge}}
\end{algorithm}


When having added a new (abstract) edge to the graph, the edge descriptor
is used to set the my\_custom\_edge and the selectedness in the graph
its my\_custom\_edge and is\_selected map .

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{add_custom_and_selectable_edge_demo.impl}

\caption{Demo of 'add\_custom\_and\_selectable\_vertex'\label{alg:add_custom_and_selectable_edge_demo}}
\end{algorithm}



\subsection{Creating a Markov-chain with custom and selectable vertices\label{sub:create_custom_and_selectable_edges_and_vertices_markov_chain}}


\subsubsection{Graph}

Figure \ref{fig:create_custom_and_selectable_edges_and_vertices_markov_chain}
shows the graph that will be reproduced:

\begin{figure}[H]
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm, semithick]   
  \tikzstyle{every state}=[]
  \node[state] (A) 
    {Sunny, You [...], 1.0, 2.0};   
  \node[state] (B) [right of=A] 
    {Rainy, Many [...], 3.0, 4.0}
  ;   
  \path (A) edge [loop above] node {AA,self,1,2} (A)
        (A) edge [bend  left] node {AB,nonself,3,4} (B)
        (B) edge [bend  left] node {BA,nonself,4,5} (A)
        (B) edge [loop above] node {BB,self,6,7} (B); 
\end{tikzpicture}

\caption{A two-state Markov chain where the edges and vertices have custom
properies. The edges' and vertices' properties are nonsensical\label{fig:create_custom_and_selectable_edges_and_vertices_markov_chain}}
\end{figure}



\subsubsection{Function to create such a graph}

Here is the code creating a two-state Markov chain with custom edges
and vertices:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_and_selectable_edges_and_vertices_markov_chain.impl}

\caption{Creating the two-state Markov chain as depicted in figure \ref{fig:create_custom_and_selectable_edges_and_vertices_markov_chain}\index{Create custom and selectable edges and vertices Markov chain}\label{alg:create_custom_and_selectable_edges_and_vertices_markov_chain}}
\end{algorithm}



\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_and_selectable_edges_and_vertices_markov_chain_demo.impl}

\caption{Demo of the 'create\_custom\_and\_selectable\_edges\_and\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_and_selectable_edges_and_vertices_markov_chain})\label{alg:create_custom_and_selectable_edges_and_vertices_markov_chain_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_custom_and_selectable_edges_and_vertices_markov_chain.dot}

\caption{.dot file created from the 'create\_custom\_and\_selectable\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_and_selectable_edges_and_vertices_markov_chain}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_custom_and_selectable_edges_and_vertices_markov_chain.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_custom_and_selectable_edges_and_vertices_markov_chain}

\caption{.svg file created from the 'create\_custom\_and\_selectable\_vertices\_markov\_chain'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_and_selectable_edges_and_vertices_markov_chain.svg}}
\end{figure}


Note how the .svg changed it appearance due to the Graphviz 'regular'
property (see chapter \ref{sub:Graphviz-attributes}): the vertex
labeled 'Sunny' is drawn according to the Graphviz 'regular' attribute,
which makes it a circle. The other vertex, labeled 'Rainy' is not
drawn as such and retained its ellipsoid appearance. 


\subsection{Creating $K_{2}$ with custom and selectable edges and vertices\label{sub:create_custom_and_selectable_edges_and_vertices_k2_graph}}


\subsubsection{Graph}

We reproduce the $K_{2}$ with custom vertices of chapter \ref{sub:create_custom_vertices_k2_graph}
, but now are vertices can be selected as well:

{[}graph here{]}


\subsubsection{Function to create such a graph}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_and_selectable_edges_and_vertices_k2_graph.impl}

\caption{Creating $K_{3}$ as depicted in figure \ref{fig:named_edges_and_vertices_k3}\index{Create custom and selectable edges and vertices K2 graph}\label{alg:create_custom_and_selectable_edges_and_vertices_k2_graph}}
\end{algorithm}


Most of the code is a slight modification of algorithm \ref{alg:create_custom_vertices_k2_graph}.
In the end, the associated my\_custom\_vertex and is\_selected properties
are obtained as boost::property\_maps and set with the desired my\_custom\_vertex
objects and selectednesses.


\subsubsection{Creating such a graph}

Here is the demo:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_custom_and_selectable_edges_and_vertices_k2_graph_demo.impl}

\caption{Demo of the 'create\_custom\_and\_selectable\_edges\_and\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_custom_and_selectable_edges_and_vertices_k2_graph})\label{alg:create_custom_and_selectable_edges_and_vertices_k2_graph_demo-1}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_custom_and_selectable_edges_and_vertices_k2_graph.dot}

\caption{.dot file created from the 'create\_custom\_and\_selectable\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_custom_and_selectable_edges_and_vertices_k2_graph}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_custom_and_selectable_edges_and_vertices_k2_graph.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_custom_and_selectable_edges_and_vertices_k2_graph}

\caption{.svg file created from the 'create\_custom\_and\_selectable\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_custom_vertices_markov_chain})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_custom_and_selectable_edges_and_vertices_k2_graph.svg}}
\end{figure}


Note how the .svg changed it appearance due to the Graphviz 'regular'
property (see chapter \ref{sub:Graphviz-attributes}): the vertex
labeled 'A' is drawn according to the Graphviz 'regular' attribute,
which makes it a circle. The other vertex, labeled 'B' is not drawn
as such and retained its ellipsoid appearance.


\section{Working on graphs with custom and selectable edges and vertices}

This chapter shows some basic operations to do on graphs with custom
and selectable edges and vertices.
\begin{itemize}
\item Storing an directed/undirected graph with custom and selectable edges
and vertices as a .dot file: chapter \ref{sub:save_custom_and_selectable_edges_and_vertices_graph_to_dot}
\item Loading a directed graph with custom and selectable edges and vertices
from a .dot file: chapter \ref{sub:load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot}
\item Loading an undirected directed graph with custom and selectable edges
amd vertices from a .dot file: chapter \ref{sub:load_undirected_custom_and_selectable_edges_and_vertices_graph_from_dot}
\end{itemize}

\subsection{Storing a graph with custom and selectable edges and vertices as
a .dot\label{sub:save_custom_and_selectable_edges_and_vertices_graph_to_dot}}

If you used the 'create\_custom\_and\_selectable\_edges\_and\_vertices\_k2\_graph'
function (algorithm \ref{alg:create_custom_and_selectable_edges_and_vertices_k2_graph})
to produce a $K_{2}$ graph with edges and vertices associated with
(1) my\_custom\_edge/my\_custom\_vertex objects, and (2) a boolean
indicating its selectedness, you can store such graphs with algorithm
\ref{alg:save_custom_and_selectable_edges_and_vertices_graph_to_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_custom_and_selectable_edges_and_vertices_graph_to_dot.impl}

\caption{Storing a graph with custom and selectable edges and vertices as a
.dot file\index{Save custom and selectable edges and vertices graph to dot}\label{alg:save_custom_and_selectable_edges_and_vertices_graph_to_dot}}
\end{algorithm}


We re-use the writer.

Special about this, is that even for Graphviz-unfriendly input, it
still works.


\subsection{Loading a directed graph with custom and selectable edges and vertices
from a .dot\label{sub:load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an directed graph with custom and selectable edges
and vertices is loaded, as shown in algorithm \ref{alg:load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot.impl}

\caption{Loading a directed graph with custom and selectable edges and vertices
from a .dot file\index{Load directed custom and selectable edges and vertices graph from
dot}\label{alg:load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot}}
\end{algorithm}


In this algorithm, first it is checked if the file to load exists.
Then an empty directed graph is created. Then, a boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}
is created with its default constructor, after which 
\begin{itemize}
\item The Graphviz attribute 'node\_id' (see chapter \ref{sub:Graphviz-attributes}
for most Graphviz attributes) is connected to a vertex its 'my\_custom\_vertex'
property
\item The Graphviz attribute 'label' is connected to a vertex its 'my\_custom\_vertex'
property
\item The Graphviz attribute 'regular' is connected to a vertex its 'is\_selected'
vertex property
\end{itemize}
Algorithm \ref{alg:load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot_demo}
shows how to use the 'load\_directed\_custom\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_directed\_custom\_and\_selectable\_edges\_and\_vertices\_graph\_from\_dot'
function\label{alg:load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how the Markov chain is created using the
'create\_custom\_vertices\_markov\_chain' function (algorithm \ref{alg:create_custom_vertices_markov_chain}),
saved and then checked to exist.


\subsection{Loading an undirected graph with custom and selectable edges and
vertices from a .dot\label{sub:load_undirected_custom_and_selectable_edges_and_vertices_graph_from_dot}}

When loading a graph from file, one needs to specify a type of graph.
In this example, an undirected graph with custom and selectable vertices
is loaded, as shown in algorithm \ref{alg:load_undirected_custom_and_selectable_edges_and_vertices_graph_from_dot}:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_custom_and_selectable_edges_and_vertices_graph_from_dot.impl}

\caption{Loading an undirected graph with custom vertices from a .dot file\index{Load undirected custom vertices graph from dot}\label{alg:load_undirected_custom_and_selectable_edges_and_vertices_graph_from_dot}}
\end{algorithm}


The only difference with loading a directed graph, is that the initial
empty graph is undirected instead. Chapter \ref{sub:load_directed_custom_and_selectable_edges_and_vertices_graph_from_dot}
describes the rationale of this function. 

Algorithm \ref{alg:load_undirected_custom_and_selectable_edges_and_vertices_graph_from_dot_demo}
shows how to use the 'load\_undirected\_custom\_vertices\_graph\_from\_dot'
function:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_custom_and_selectable_edges_and_vertices_graph_from_dot_demo.impl}

\caption{Demonstration of the 'load\_undirected\_custom\_and\_selectable\_edges\_and\_vertices\_graph\_from\_dot'
function\label{alg:load_undirected_custom_and_selectable_edges_and_vertices_graph_from_dot_demo}}
\end{algorithm}


This demonstration shows how $K_{2}$ with custom vertices is created
using the 'create\_custom\_vertices\_k2\_graph' function (algorithm
\ref{alg:create_custom_vertices_k2_graph}), saved and then checked
to exist.




\section{Building graphs with a graph name\label{sec:Building-graphs-with-a-graph-name}}

Up until now, the graphs created have had no properties themselves.
Sure, the edges and vertices have had properties, but the graph itself
has had none. Until now.

In this chapter, graphs will be created with a graph name of type
std::string
\begin{itemize}
\item An empty directed graph with a graph name: see chapter 
\item An empty undirected graph with a graph name: see chapter 
\item A two-state Markov chain with a graph name: see chapter
\item $K_{3}$with a graph name: see chapter 
\end{itemize}
In the process, some basic (sometimes bordering trivial) functions
are shown:
\begin{itemize}
\item Getting a graph its name: see chapter 
\item Setting a graph its name: see chapter
\end{itemize}

\subsection{Create an empty directed graph with a graph name property\label{sub:create_empty_directed_graph_with_graph_name}}

Algorithm \ref{alg:create_empty_directed_graph_with_graph_name} shows
the function to create an empty directed graph with a graph name.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_graph_with_graph_name.impl}

\caption{Creating an empty directed graph with a graph name\index{Create empty directed graph with graph name}\label{alg:create_empty_directed_graph_with_graph_name}}
\end{algorithm}


This boost::adjacency\_list is of the following type:
\begin{itemize}
\item the first 'boost::vecS'\index{boost::vecS}: select (that is what
the 'S\index{S}' means) that out edges are stored in a std::vector.
This is the default way.
\item the second 'boost::vecS'\index{boost::vecS}: select that the graph
vertices are stored in a std::vector. This is the default way.
\item 'boost::directedS'\index{boost::directedS}: select that the graph
is directed. This is the default selectedness
\item the first 'boost::no\_property'\index{boost::no_property@boost::no\_property}:
the vertices have no properties. This is the default (non-)property
\item the second 'boost::no\_property'\index{boost::no_property@boost::no\_property}:
the vertices have no properties. This is the default (non-)propert
\item 'boost::property<boost::graph\_name\_t, std::string>'\index{boost::property}\index{boost::graph_name_t@boost::graph\_name\_t}:
the graph itself has a single property: its boost::graph\_name\index{boost::graph_name@boost::graph\_name}
has type std::string
\end{itemize}
Algorithm \ref{alg:create_empty_directed_graph_with_graph_name_demo}
demonstrates the 'create\_empty\_directed\_graph\_with\_graph\_name'
function.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_directed_graph_with_graph_name_demo.impl}

\caption{Demonstration of 'create\_empty\_directed\_graph\_with\_graph\_name'\label{alg:create_empty_directed_graph_with_graph_name_demo}}
\end{algorithm}



\subsection{Create an empty undirected graph with a graph name property\label{sub:create_empty_undirected_graph_with_graph_name}}

Algorithm \ref{alg:create_empty_undirected_graph_with_graph_name}
shows the function to create an empty undirected graph with a graph
name.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_graph_with_graph_name.impl}

\caption{Creating an empty undirected graph with a graph name\index{Create empty undirected graph with graph name}\label{alg:create_empty_undirected_graph_with_graph_name}}
\end{algorithm}


This code is very similar to the code described in chapter \ref{alg:create_empty_directed_graph_with_graph_name},
except that the directedness (the third template argument) is undirected
(due to the boost::undirectedS\index{boost::undirectedS}).

Algorithm \ref{alg:create_empty_undirected_graph_with_graph_name_demo}
demonstrates the 'create\_empty\_undirected\_graph\_with\_graph\_name'
function.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_empty_undirected_graph_with_graph_name_demo.impl}

\caption{Demonstration of 'create\_empty\_undirected\_graph\_with\_graph\_name'\label{alg:create_empty_undirected_graph_with_graph_name_demo}}
\end{algorithm}



\subsection{Get a graph its name property\label{sub:get_graph_name}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_graph_name.impl}

\caption{Get a graph its name\index{Get graph name}\label{alg:get_graph_name}}
\end{algorithm}


Algorithm \ref{alg:get_graph_name_demo} demonstrates the 'get\_graph\_name'
function.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_graph_name_demo.impl}

\caption{Demonstration of 'get\_graph\_name'\label{alg:get_graph_name_demo}}
\end{algorithm}



\subsection{Set a graph its name property\label{sub:set_graph_name}}

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_graph_name.impl}

\caption{Set a graph its name\index{Set graph name}\label{alg:set_graph_name}}
\end{algorithm}


Algorithm \ref{alg:set_graph_name_demo} demonstrates the 'set\_graph\_name'
function.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{set_graph_name_demo.impl}

\caption{Demonstration of 'set\_graph\_name'\label{alg:set_graph_name_demo}}
\end{algorithm}



\subsection{Create a directed graph with a graph name property\label{sub:create_markov_chain_with_graph_name}}


\subsubsection{Graph}

See figure \ref{fig:markov_chain}.


\subsubsection{Function to create such a graph}

Algorithm \ref{alg:create_markov_chain_with_graph_name} shows the
function to create an empty directed graph with a graph name.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_markov_chain_with_graph_name.impl}

\caption{Creating a two-state Markov chain with a graph name\index{Create Markov chain with graph name}\label{alg:create_markov_chain_with_graph_name}}
\end{algorithm}



\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_markov_chain_with_graph_name_demo} demonstrates
the 'create\_markov\_chain\_with\_graph\_name' function.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_markov_chain_with_graph_name_demo.impl}

\caption{Demonstration of 'create\_markov\_chain\_with\_graph\_name'\label{alg:create_markov_chain_with_graph_name_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_markov_chain_with_graph_name.dot}

\caption{.dot file created from the 'create\_markov\_chain\_with\_graph\_name'
function (algorithm \ref{alg:create_markov_chain_with_graph_name}),
converted from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_markov_chain_with_graph_name.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_markov_chain_with_graph_name}

\caption{.svg file created from the 'create\_markov\_chain\_with\_graph\_name'
function (algorithm \ref{alg:create_markov_chain_with_graph_name})
its .dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_markov_chain_with_graph_name.svg}}
\end{figure}



\subsection{Create an undirected graph with a graph name property\label{sub:create_k2_graph_with_graph_name}}


\subsubsection{Graph}

See figure \ref{fig:k2_graph}.


\subsubsection{Function to create such a graph}

Algorithm \ref{alg:create_k2_graph_with_graph_name} shows the function
to create K2 graph with a graph name.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_k2_graph_with_graph_name.impl}

\caption{Creating a K2 graph with a graph name\index{Create K2 graph with graph name}\label{alg:create_k2_graph_with_graph_name}}
\end{algorithm}



\subsubsection{Creating such a graph}

Algorithm \ref{alg:create_k2_graph_with_graph_name_demo} demonstrates
the 'create\_k2\_graph\_with\_graph\_name' function.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{create_k2_graph_with_graph_name_demo.impl}

\caption{Demonstration of 'create\_k2\_graph\_with\_graph\_name'\label{alg:create_k2_graph_with_graph_name_demo}}
\end{algorithm}



\subsubsection{The .dot file produced}

\begin{algorithm}[H]
\verbatiminput{create_k2_graph_with_graph_name.dot}

\caption{.dot file created from the 'create\_k2\_graph\_with\_graph\_name'
function (algorithm \ref{alg:create_k2_graph_with_graph_name}), converted
from graph to .dot file using algorithm \ref{alg:save_graph_to_dot}\label{alg:create_k2_graph_with_graph_name.dot}}
\end{algorithm}



\subsubsection{The .svg file produced}

\begin{figure}[H]
\includegraphics{create_k2_graph_with_graph_name}

\caption{.svg file created from the 'create\_k2\_graph\_with\_graph\_name'
function (algorithm \ref{alg:create_k2_graph_with_graph_name}) its
.dot file, converted from .dot file to .svg using algorithm \ref{alg:convert_dot_to_svg}\label{fig:create_k2_graph_with_graph_name.svg}}
\end{figure}



\section{Working on graphs with a graph name}


\subsection{Storing a graph with a graph name property as a .dot file\label{sub:save_graph_with_graph_name_to_dot}}

This works:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{save_graph_with_graph_name_to_dot.impl}

\caption{Storing a graph with a graph name as a .dot file\index{Save graph with graph name to dot}\label{alg:save_graph_with_graph_name_to_dot}}
\end{algorithm}



\subsection{Loading a directed graph with a graph name property from a .dot file\label{sub:load_directed_graph_with_graph_name_from_dot}}

This will result in a directed graph with a name:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_directed_graph_with_graph_name_from_dot.impl}

\caption{Loading a directed graph with a graph name from a .dot file\index{Load directed custom edges and vertices graph from dot}\label{alg:load_directed_graph_with_graph_name_from_dot}}
\end{algorithm}



\subsection{Loading an undirected graph with a graph name property from a .dot
file\label{sub:load_undirected_graph_with_graph_name_from_dot}}

This will result in an undirected graph with a name:

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{load_undirected_graph_with_graph_name_from_dot.impl}

\caption{Loading an undirected graph with a graph name from a .dot file\index{Load undirected custom edges and vertices graph from dot}\label{alg:load_undirected_graph_with_graph_name_from_dot}}
\end{algorithm}



\section{Other graph functions\label{sec:Other-graph-functions}}

Some functions that did not fit in.


\subsection{Encode a std::string to a Graphviz-friendly format\label{sub:graphviz_encode}}

You may want to use a label with spaces, comma's and/or quotes. Saving
and loading these, will result in problem. This function replaces
these special characters by a rare combination of ordinary characters.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{graphviz_encode.impl}

\caption{Encode a std::string to a Graphviz-friendly format\index{graphviz encode}\label{alg:graphviz_encode}}
\end{algorithm}



\subsection{Decode a std::string from a Graphviz-friendly format\label{sub:graphviz_decode}}

This function undoes the 'graphviz\_encode' function (algorithm \ref{alg:graphviz_encode})
and thus converts a Graphviz-friendly std::string to the original
human-friendly std::string.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{graphviz_decode.impl}

\caption{Decode a std::string from a Graphviz-friendly format to a human-friendly
format\index{graphviz decode}\label{alg:graphviz_decode}}
\end{algorithm}



\subsection{Check if a std::string is Graphviz-friendly\label{sub:is_graphviz_friendly}}

There are pieces where I check if a std::string is Graphviz-friendly.
This is done only where it matters. If it is tested not to matter,
'is\_graphviz\_friendly' is absent.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{is_graphviz_friendly.impl}

\caption{Check if a std::string is Graphviz-friendly\index{is_graphviz_friendly@is\_graphviz\_friendly}\label{alg:is_graphviz_friendly}}
\end{algorithm}



\section{Misc functions}

These are some function I needed for creating this tutorial. Although
they are not important for working with graphs, I used these heavily.
These functions may be compiler-dependent, platform-dependent and/or
there may be superior alternatives. I just add them for completeness.


\subsection{Getting a data type as a std::string\label{sub:get_type_name}}

This function will only work under GCC. I found this code at: \url{http://stackoverflow.com/questions/1055452/c-get-name-of-type-in-template}
. Thanks to 'm-dudley' (Stack Overflow userpage at \url{http://stackoverflow.com/users/111327/m-dudley}
).

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{get_type_name.impl}

\caption{Getting a data type its name as a std::string\index{Get type name}\label{alg:get_type_name}}
\end{algorithm}



\subsection{Convert a .dot to .svg\label{sub:convert_dot_to_svg}}

All illustrations in this tutorial are created by converting .dot
to a .svg ('Scalable Vector Graphic') file. This function assumes
the program 'dot' is installed, which is part of Graphviz.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{convert_dot_to_svg.impl}

\caption{Convert a .dot file to a .svg\index{Convert dot to svg}\label{alg:convert_dot_to_svg}}
\end{algorithm}


'convert\_dot\_to\_svg' makes a system call to the prgram 'dot' to
convert the .dot file to an .svg file.


\subsection{Check if a file exists\label{sub:is_regular_file}}

Not the most smart way perhaps, but it does only use the STL.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{is_regular_file.impl}

\caption{Check if a file exists\index{Is regular file}\label{alg:is_regular_file}}
\end{algorithm}



\section{Errors}

Some common errors.


\subsection{Formed reference to void\label{sub:formed_reference_to_void}}

This compile-time error occurs when you create a graph without a certain
property, then subsequently reading that property, as in algorithm
\ref{alg:formed_reference_to_void}: 

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{formed_reference_to_void.impl}

\caption{Creating the error 'formed reference to void'\index{Formed reference to void}\label{alg:formed_reference_to_void}}
\end{algorithm}


In algorithm \ref{alg:formed_reference_to_void} a graph is created
with vertices of no properties. Then the names of these vertices,
which do not exists, are tried to be read. If you want to read the
names of the vertices, supply a graph that has this property.


\subsection{No matching function for call to 'clear\_out\_edges'\label{sub:no_matching_function_for_call_to_clear_out_edges}}

This compile-time error occurs when you want to clear the outward
edges from a vertex in an undirected graph. 

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{no_matching_function_for_call_to_clear_out_edges.impl}

\caption{Creating the error 'no matching function for call to clear\_out\_edges'\index{No matching function for call to clear_out_edges@No matching function for call to clear\_out\_edges}\label{alg:no_matching_function_for_call_to_clear_out_edges}}
\end{algorithm}


In algorithm \ref{alg:no_matching_function_for_call_to_clear_out_edges}
an undirected graph is created, a vertex descriptor is obtained, then
its out edges are tried to be cleared. Either use a directed graph
(which has out edges), or use the 'boost::clear\_vertex' function
instead.


\subsection{No matching function for call to 'clear\_in\_edges'\label{sub:no_matching_function_for_call_to_clear_in_edges}}

See chapter \ref{sub:no_matching_function_for_call_to_clear_out_edges}.


\subsection{Undefined reference to boost::detail::graph::read\_graphviz\_new\label{sub:undefined_reference_to_read_graphviz_new}\index{read_graphviz_new@read\_graphviz\_new}\index{Undefined reference to read_graphviz_new@Undefined reference to read\_graphviz\_new}\index{read_graphviz_new, undefined reference@read\_graphviz\_new, undefined reference}}

You will have to link\index{link} against the Boost.Graph and Boost.Regex
libraries. In Qt Creator, this is achieved by adding these lines to
your Qt Creator project file:

\begin{lstlisting}
LIBS += -lboost_graph -lboost_regex 
\end{lstlisting}



\subsection{Property not found: node\_id\label{sub:property_not_found_node_id}\index{node_id@node\_id}\index{Property not found}\index{Property not found: node_id@Property not found: node\_id}}

When loading a graph from file (as in chapter \ref{sub:load_undirected_graph_from_dot})
you will be using boost::read\_graphviz\index{boost::read_graphviz@boost::read\_graphviz}.
boost::read\_graphviz\index{boost::read_graphviz@boost::read\_graphviz}
needs a third argument, of type boost::dynamic\_properties\index{boost::dynamic_properties@boost::dynamic\_properties}.
When a graph does not have properties, do not use a default constructed
version, but initializate with 'boost::ignore\_other\_properties'\index{boost::ignore_other_properties@boost::ignore\_other\_properties}
as a constructor argument instead. Algorithm \ref{alg:property_not_found_node_id}
shows how to trigger this run-time error.

\begin{algorithm}[H]
\lstinputlisting[breaklines=true,language={C++}]{property_not_found_node_id.impl}

\caption{Creating the error 'Property not found: node\_id'\index{Property not found: node_id@Property not found: node\_id}\label{alg:property_not_found_node_id}}
\end{algorithm}



\subsection{Stream zeroes}

When loading a graph from a .dot file, in operator>\textcompwordmark{}>,
I encountered reading zeroes, where I expected an XML formatted string:

\begin{lstlisting}
std::istream& ribi::cmap::operator>>(std::istream& is, my_class& any_class) noexcept
{
  std::string s;
  is >> s; //s has an XML format
  assert(s != "0");
  any_class = my_class(s);
  return is;
}
\end{lstlisting}


This was because I misconfigured the reader. I did (heavily simplified
code):

\begin{lstlisting}
graph load_from_dot(const std::string& dot_filename)
{
  std::ifstream f(dot_filename.c_str());
  graph g;
  boost::dynamic_properties dp;
  dp.property("node_id", get(boost::vertex_custom_type, g));
  dp.property("label", get(boost::vertex_custom_type, g));
  boost::read_graphviz(f,g,dp);
  return g;
}
\end{lstlisting}


Where it should have been:

\begin{lstlisting}
graph load_from_dot(const std::string& dot_filename)
{
  std::ifstream f(dot_filename.c_str());
  graph g;
  boost::dynamic_properties dp(boost::ignore_other_properties);
  dp.property("label", get(boost::vertex_custom_type, g));
  boost::read_graphviz(f,g,dp);
  return g;
}
\end{lstlisting}


The explanation is that by setting the boost::dynamic\_property 'node\_id'
to 'boost::vertex\_custom\_type', operator>\textcompwordmark{}> will
receive the node indices. 

An alternative, but less clean solution, is to let operator>\textcompwordmark{}>
ignore the node indices:

\begin{lstlisting}
std::istream& ribi::cmap::operator>>(std::istream& is, my_class& any_class) noexcept
{
  std::string s;
  is >> s; //s has an XML format
  if (!is_xml(s)) { //Ignore node index
    any_class_class = my_class(); 
  }
  else {
    any_class_class = my_class(s);
  }
  return is;
}
\end{lstlisting}



\section{Appendix}


\subsection{List of all edge, graph and vertex properties\label{sub:all_properties}\index{All edge properties}\index{All graph properties}\index{All vertex properties}\index{Edge properties}\index{Graph properties}\index{Vertex properties}}

The following list is obtained from the file 'boost/graph/properties.hpp'.

\begin{tabular}{|c|c|c|}
\hline 
Edge & Graph & Vertex\tabularnewline
\hline 
\hline 
edge\_all & graph\_all & vertex\_all\tabularnewline
\hline 
edge\_bundle & graph\_bundle & vertex\_bundle\tabularnewline
\hline 
edge\_capacity & graph\_name & vertex\_centrality\tabularnewline
\hline 
edge\_centrality & graph\_visitor & vertex\_color\tabularnewline
\hline 
edge\_color &  & vertex\_current\_degree\tabularnewline
\hline 
edge\_discover\_time &  & vertex\_degree\tabularnewline
\hline 
edge\_finished &  & vertex\_discover\_time\tabularnewline
\hline 
edge\_flow &  & vertex\_distance\tabularnewline
\hline 
edge\_global &  & vertex\_distance2\tabularnewline
\hline 
edge\_index &  & vertex\_finish\_time\tabularnewline
\hline 
edge\_local &  & vertex\_global\tabularnewline
\hline 
edge\_local\_index &  & vertex\_in\_degree\tabularnewline
\hline 
edge\_name &  & vertex\_index\tabularnewline
\hline 
edge\_owner &  & vertex\_index1\tabularnewline
\hline 
edge\_residual\_capacity &  & vertex\_index2\tabularnewline
\hline 
edge\_reverse &  & vertex\_local\tabularnewline
\hline 
edge\_underlying &  & vertex\_local\_index\tabularnewline
\hline 
edge\_update &  & vertex\_lowpoint\tabularnewline
\hline 
edge\_weight &  & vertex\_name\tabularnewline
\hline 
edge\_weight2 &  & vertex\_out\_degree\tabularnewline
\hline 
 &  & vertex\_owner\tabularnewline
\hline 
 &  & vertex\_potential\tabularnewline
\hline 
 &  & vertex\_predecessor\tabularnewline
\hline 
 &  & vertex\_priority\tabularnewline
\hline 
 &  & vertex\_rank\tabularnewline
\hline 
 &  & vertex\_root\tabularnewline
\hline 
 &  & vertex\_underlying\tabularnewline
\hline 
 &  & vertex\_update\tabularnewline
\hline 
\end{tabular}


\subsection{Graphviz attributes\label{sub:Graphviz-attributes}}

List created from \url{www.graphviz.org/content/attrs}, where only
the attributes that are supported by all formats are listed:

\begin{tabular}{|c|c|c|}
\hline 
Edge & Graph & Vertex\tabularnewline
\hline 
\hline 
arrowhead & \_background & color\tabularnewline
\hline 
arrowsize & bgcolor & colorscheme\tabularnewline
\hline 
arrowtail & center & comment\tabularnewline
\hline 
color & charset & distortion\tabularnewline
\hline 
colorscheme & color & fillcolor\tabularnewline
\hline 
comment & colorscheme & fixedsize\tabularnewline
\hline 
decorate & comment & fontcolor\tabularnewline
\hline 
dir & concentrate & fontname\tabularnewline
\hline 
fillcolor & fillcolor & fontsize\tabularnewline
\hline 
fontcolor & fontcolor & gradientangle\tabularnewline
\hline 
fontname & fontname & height\tabularnewline
\hline 
fontsize & fontpath & image\tabularnewline
\hline 
gradientangle & fontsize & imagescale\tabularnewline
\hline 
headclip & forcelabels & label\tabularnewline
\hline 
headlabel & gradientangle & labelloc\tabularnewline
\hline 
headport & imagepath & layer\tabularnewline
\hline 
label & label & margin\tabularnewline
\hline 
labelangle & labeljust & nojustify\tabularnewline
\hline 
labeldistance & labelloc & orientation\tabularnewline
\hline 
labelfloat & landscape & penwidth\tabularnewline
\hline 
labelfontcolor & layerlistsep & peripheries\tabularnewline
\hline 
labelfontname & layers & pos\tabularnewline
\hline 
labelfontsize & layerselect & regular\tabularnewline
\hline 
layer & layersep & samplepoints\tabularnewline
\hline 
nojustify & layout & shape\tabularnewline
\hline 
penwidth & margin & shapefile\tabularnewline
\hline 
pos & nodesep & sides\tabularnewline
\hline 
style & nojustify & skew\tabularnewline
\hline 
tailclip & orientation & sortv\tabularnewline
\hline 
taillabel & outputorder & style\tabularnewline
\hline 
tailport & pack & width\tabularnewline
\hline 
weight & packmode & xlabel\tabularnewline
\hline 
xlabel & pad & z\tabularnewline
\hline 
 & page & \tabularnewline
\hline 
 & pagedir & \tabularnewline
\hline 
 & penwidth & \tabularnewline
\hline 
 & quantum & \tabularnewline
\hline 
 & ratio & \tabularnewline
\hline 
 & rotate & \tabularnewline
\hline 
 & size & \tabularnewline
\hline 
 & sortv & \tabularnewline
\hline 
 & splines & \tabularnewline
\hline 
 & style & \tabularnewline
\hline 
 & viewport & \tabularnewline
\hline 
\end{tabular}

\bibliographystyle{plain}
\bibliography{boost_graph_tutorial}


\printindex{}
\end{document}
